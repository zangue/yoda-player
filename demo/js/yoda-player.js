!function(Q,U){"object"==typeof exports&&"object"==typeof module?module.exports=U():"function"==typeof define&&define.amd?define([],U):"object"==typeof exports?exports.yoda=U():Q.yoda=U()}(self,(()=>(()=>{"use strict";var __webpack_modules__={743:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ src)\n});\n\n;// CONCATENATED MODULE: ./src/dash/types.ts\nvar MediaType;\n(function (MediaType) {\n    MediaType[\"VIDEO\"] = \"video\";\n    MediaType[\"AUDIO\"] = \"audio\";\n})(MediaType || (MediaType = {}));\nvar StreamType;\n(function (StreamType) {\n    StreamType[StreamType[\"LIVE\"] = 0] = \"LIVE\";\n    StreamType[StreamType[\"VOD\"] = 1] = \"VOD\";\n})(StreamType || (StreamType = {}));\n\n;// CONCATENATED MODULE: ./src/dash/parser-utils.ts\n/**\n * A collection of utility methods to parse MPEG-DASH manifests.\n */\nclass ParserUtils {\n    static parseXml(data) {\n        let parser = new DOMParser();\n        let xml = parser.parseFromString(data, 'text/xml');\n        if (xml && xml.documentElement.tagName === 'MPD') {\n            return xml.documentElement;\n        }\n        return null;\n    }\n    static getChildren(node, tagName) {\n        const childElements = [];\n        for (const child of node.childNodes) {\n            if (child instanceof Element && child.tagName === tagName) {\n                childElements.push(child);\n            }\n        }\n        return childElements;\n    }\n    static getFirstChild(node, tagName) {\n        const children = ParserUtils.getChildren(node, tagName);\n        return (children === null || children === void 0 ? void 0 : children[0]) || null;\n    }\n    static parseIsoDuration(durationString) {\n        const secondsInYear = 365 * 24 * 60 * 60;\n        const secondsInMonth = 30 * 24 * 60 * 60;\n        const secondsInDay = 24 * 60 * 60;\n        const secondsInHour = 60 * 60;\n        const secondsInMinute = 60;\n        if (!durationString) {\n            return null;\n        }\n        const regex = /^([-])?P(([\\d.]*)Y)?(([\\d.]*)M)?(([\\d.]*)D)?T?(([\\d.]*)H)?(([\\d.]*)M)?(([\\d.]*)S)?/;\n        const match = regex.exec(durationString);\n        let duration = (parseFloat((match === null || match === void 0 ? void 0 : match[2]) || '0') * secondsInYear +\n            parseFloat((match === null || match === void 0 ? void 0 : match[4]) || '0') * secondsInMonth +\n            parseFloat((match === null || match === void 0 ? void 0 : match[6]) || '0') * secondsInDay +\n            parseFloat((match === null || match === void 0 ? void 0 : match[8]) || '0') * secondsInHour +\n            parseFloat((match === null || match === void 0 ? void 0 : match[10]) || '0') * secondsInMinute +\n            parseFloat((match === null || match === void 0 ? void 0 : match[12]) || '0'));\n        if (typeof (match === null || match === void 0 ? void 0 : match[1]) !== 'undefined') {\n            duration = -duration;\n        }\n        return duration;\n    }\n    static parseDate(dateString) {\n        if (!dateString) {\n            return null;\n        }\n        // Make sure to use UTC time instead of local time zone\n        if (!dateString.endsWith('Z')) {\n            dateString += 'Z';\n        }\n        const result = Date.parse(dateString);\n        return (!isNaN(result) ? Math.floor(result / 1000.0) : null);\n    }\n    static resolveTemplateUrl(url, identifiers, baseUrl) {\n        let resolvedTemplate = url;\n        if (identifiers.representationId) {\n            resolvedTemplate = resolvedTemplate.replace('$RepresentationID$', String(identifiers.representationId));\n        }\n        if (identifiers.number) {\n            resolvedTemplate = resolvedTemplate.replace('$Number$', String(identifiers.number));\n        }\n        if (identifiers.subNumber) {\n            resolvedTemplate = resolvedTemplate.replace('$SubNumber$', String(identifiers.number));\n        }\n        if (identifiers.bandwidth) {\n            resolvedTemplate = resolvedTemplate.replace('$Bandwidth$', String(identifiers.bandwidth));\n        }\n        if (identifiers.time) {\n            resolvedTemplate = resolvedTemplate.replace('$Time$', String(identifiers.time));\n        }\n        if (baseUrl === null || baseUrl === void 0 ? void 0 : baseUrl.startsWith('http')) {\n            resolvedTemplate = new window.URL(resolvedTemplate, baseUrl).href;\n        }\n        return resolvedTemplate;\n    }\n    static getTypeFromMimeType(mimeType) {\n        if (!mimeType) {\n            return '';\n        }\n        return mimeType.split('/')[0] || '';\n    }\n    static getFullMimeType(stream) {\n        let fullMimeType = stream.mimeType;\n        if (stream.codecs) {\n            fullMimeType += '; codecs=\"' + stream.codecs + '\"';\n        }\n        return fullMimeType;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/utils/async-task.ts\nclass AsyncTask {\n    constructor() {\n        this.done = () => { };\n        this.fail = () => { };\n        this.promise = new Promise((resolve, reject) => {\n            this.done = (value) => resolve(value);\n            this.fail = (error) => reject(error);\n        });\n    }\n    timeOut() {\n        return this;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/utils/time-ranges.ts\nclass TimeRangesUtils {\n    static getBufferedInfo(b) {\n        if (!b) {\n            return [];\n        }\n        const ret = [];\n        for (let i = 0; i < b.length; i++) {\n            ret.push({ start: b.start(i), end: b.end(i) });\n        }\n        return ret;\n    }\n    static bufferedAheadOf(b, time) {\n        if (!b || !b.length) {\n            return 0;\n        }\n        // Workaround Safari bug: https://bit.ly/2trx6O8\n        if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n            return 0;\n        }\n        // We calculate the buffered amount by ONLY accounting for the content\n        // buffered (i.e. we ignore the times of the gaps).  We also buffer through\n        // all gaps.\n        // Therefore, we start at the end and add up all buffers until |time|.\n        let result = 0;\n        for (const { start, end } of TimeRangesUtils.getBufferedInfo(b)) {\n            if (end > time) {\n                result += end - Math.max(start, time);\n            }\n        }\n        return result;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/mse-adapter.ts\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n/**\n * The a wrapper class around the MSE APIs to provide a \"better\" handle thereof.\n */\nclass MseAdapter {\n    constructor(video) {\n        this.mediaSource_ = null;\n        this.objectUrl_ = '';\n        this.sourceBuffers_ = new Map();\n        this.appendQ_ = new Map();\n        this.video_ = video;\n        this.mediaSourceOpenTask_ = new AsyncTask();\n        this.onUpdateEndVideo_ = (_) => {\n            this.onUpdateEnd_(MediaType.VIDEO);\n        };\n        this.onErrorVideo_ = (e) => {\n            console.log('(mse) video source buffer error', e);\n        };\n        this.onUpdateEndAudio_ = (_) => {\n            this.onUpdateEnd_(MediaType.AUDIO);\n        };\n        this.onErrorAudio_ = (e) => {\n            console.log('(mse) audio source buffer error', e);\n        };\n    }\n    openMediaSource() {\n        const onSourceOpen = () => {\n            var _a;\n            console.log('media source is open...');\n            (_a = this.mediaSource_) === null || _a === void 0 ? void 0 : _a.removeEventListener('sourceopen', onSourceOpen);\n            this.mediaSourceOpenTask_.done();\n        };\n        this.mediaSource_ = new MediaSource();\n        this.mediaSource_.addEventListener('sourceopen', onSourceOpen);\n        this.objectUrl_ = window.URL.createObjectURL(this.mediaSource_);\n        this.video_.src = this.objectUrl_;\n        return this.mediaSourceOpenTask_.promise;\n    }\n    stop() {\n        // TODO - Abort ongoing operations on source buffers first!\n        this.sourceBuffers_.forEach((sourceBuffer, mediaType) => {\n            if (mediaType === MediaType.VIDEO) {\n                sourceBuffer.removeEventListener('error', this.onErrorVideo_);\n                sourceBuffer.removeEventListener('updateend', this.onUpdateEndVideo_);\n            }\n        });\n    }\n    closeMediaSource() {\n        this.stop();\n        if (this.objectUrl_) {\n            window.URL.revokeObjectURL(this.objectUrl_);\n        }\n        this.sourceBuffers_.forEach(sourceBuffer => {\n            var _a;\n            (_a = this.mediaSource_) === null || _a === void 0 ? void 0 : _a.removeSourceBuffer(sourceBuffer);\n        });\n        this.mediaSource_ = null;\n    }\n    ;\n    setupSourceBuffers(streamMap) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.mediaSourceOpenTask_;\n            if (!this.mediaSource_) {\n                throw new Error('No MediaSource!');\n            }\n            const videoStream = streamMap.get(MediaType.VIDEO);\n            const audioStream = streamMap.get(MediaType.AUDIO);\n            if (videoStream) {\n                this.addSourceBuffer_(MediaType.VIDEO, videoStream);\n            }\n            if (audioStream) {\n                this.addSourceBuffer_(MediaType.AUDIO, audioStream);\n            }\n            if (this.sourceBuffers_.size < 1) {\n                console.warn('Could not setup source buffers...');\n            }\n        });\n    }\n    appendBuffer(mediaType, data) {\n        var _a;\n        const sourceBuffer = this.sourceBuffers_.get(mediaType);\n        if (sourceBuffer) {\n            if (!this.appendQ_.has(mediaType)) {\n                this.appendQ_.set(mediaType, []);\n            }\n            const appendContext = {\n                mediaType,\n                data,\n                operation: new AsyncTask(),\n                scheduled: false\n            };\n            (_a = this.appendQ_.get(mediaType)) === null || _a === void 0 ? void 0 : _a.push(appendContext);\n            this.runQueue_(mediaType);\n            return appendContext.operation.promise;\n        }\n        return Promise.reject();\n    }\n    setCurrentTime(time) {\n        console.assert(time >= 0, 'Current time can not be negative');\n        this.video_.currentTime = time;\n    }\n    setDuration(duration) {\n        if (this.mediaSource_) {\n            this.mediaSource_.duration = duration;\n        }\n    }\n    getBufferEnd(mediaType) {\n        const sourceBuffer = this.sourceBuffers_.get(mediaType);\n        if (sourceBuffer) {\n            try {\n                const ranges = sourceBuffer.buffered;\n                if (ranges !== null && typeof ranges !== 'undefined' && ranges.length) {\n                    return ranges.end(ranges.length - 1);\n                }\n            }\n            catch (e) {\n                console.error('Could not get time ranges for ', mediaType, e);\n            }\n        }\n        return null;\n    }\n    getBufferedAheadOf(mediaType, time) {\n        let bufferedAhead = 0;\n        const sourceBuffer = this.sourceBuffers_.get(mediaType);\n        if (sourceBuffer) {\n            try {\n                const ranges = sourceBuffer.buffered;\n                bufferedAhead = TimeRangesUtils.bufferedAheadOf(ranges, time);\n            }\n            catch (e) {\n                console.error('Could not get time ranges for ', mediaType, e);\n            }\n        }\n        return bufferedAhead;\n    }\n    onUpdateEnd_(mediaType) {\n        const queue = this.appendQ_.get(mediaType);\n        // Pop from queue\n        const context = queue === null || queue === void 0 ? void 0 : queue.shift();\n        if (context) {\n            console.assert(context.scheduled, 'Bug: (mse) first item in the queue should have been scheduled!');\n            // Resolve operation promise\n            context.operation.done();\n            // Run queue\n            this.runQueue_(mediaType);\n        }\n    }\n    runQueue_(mediaType) {\n        const sourceBuffer = this.sourceBuffers_.get(mediaType);\n        const queue = this.appendQ_.get(mediaType);\n        console.assert(!!queue || !!sourceBuffer, 'Bug: (mse) invalid call to runQueue_()');\n        if (!queue || !sourceBuffer) {\n            console.warn('Unsuccessful attempt to update buffer');\n            return;\n        }\n        if (queue.length === 0) {\n            // Nothing to to\n            return;\n        }\n        if (sourceBuffer.updating) {\n            // Wait for updateend\n            return;\n        }\n        // FIFO\n        const next = queue[0];\n        console.assert(!next.scheduled, 'Bug: (mse) found scheduled item in run queue!');\n        next.scheduled = true;\n        sourceBuffer.appendBuffer(new Uint8Array(next.data));\n    }\n    /**\n     * Create a source buffer for |mediaType| and add it to the media source\n     * @param mediaType\n     * @param stream\n     */\n    addSourceBuffer_(mediaType, stream) {\n        if (this.mediaSource_) {\n            const fullMimeType = ParserUtils.getFullMimeType(stream);\n            const supportedByPlatform = MediaSource.isTypeSupported(fullMimeType);\n            console.assert(mediaType === MediaType.VIDEO || mediaType === MediaType.AUDIO, 'Invalid media type!');\n            console.assert(supportedByPlatform, 'Type must supported by platform!', fullMimeType);\n            if (!supportedByPlatform) {\n                console.warn(`Skipping ${mediaType} stream because not supported by platform.`);\n                return;\n            }\n            const sourceBuffer = this.mediaSource_.addSourceBuffer(fullMimeType);\n            if (mediaType === MediaType.VIDEO) {\n                sourceBuffer.addEventListener('updateend', this.onUpdateEndVideo_);\n                sourceBuffer.addEventListener('error', this.onErrorVideo_);\n                this.sourceBuffers_.set(MediaType.VIDEO, sourceBuffer);\n            }\n            if (mediaType === MediaType.AUDIO) {\n                sourceBuffer.addEventListener('updateend', this.onUpdateEndAudio_);\n                sourceBuffer.addEventListener('error', this.onErrorAudio_);\n                this.sourceBuffers_.set(MediaType.AUDIO, sourceBuffer);\n            }\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./src/utils/timer.ts\nclass Timer {\n    constructor(handler) {\n        this.timerId_ = null;\n        this.clearMethod_ = null;\n        this.onTick_ = handler;\n    }\n    tickAfter(seconds) {\n        return this.setTimer_(seconds, false);\n    }\n    tickEvery(seconds) {\n        return this.setTimer_(seconds, true);\n    }\n    clear() {\n        if (this.timerId_ && this.clearMethod_) {\n            this.clearMethod_(this.timerId_);\n            this.timerId_ = null;\n            this.clearMethod_ = null;\n        }\n    }\n    setTimer_(seconds, isPeriodic) {\n        this.clear();\n        const cb = () => {\n            if (this.timerId_) {\n                this.onTick_();\n            }\n        };\n        if (isPeriodic) {\n            this.timerId_ = window.setInterval(cb, seconds * 1000);\n            this.clearMethod_ = clearInterval.bind(window);\n        }\n        else {\n            this.timerId_ = window.setTimeout(cb, seconds * 1000);\n            this.clearMethod_ = clearTimeout.bind(window);\n        }\n        return this;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/utils/network.ts\nclass HttpRequest {\n    constructor(url) {\n        this.method_ = 'GET';\n        this.headers_ = new Map();\n        this.body_ = null;\n        this.responseType_ = 'arraybuffer';\n        this.url_ = url;\n    }\n    get url() {\n        return this.url_;\n    }\n    set url(newUrl) {\n        this.url_ = newUrl;\n    }\n    get method() {\n        return this.method_;\n    }\n    set method(newMethod) {\n        this.method_ = newMethod;\n    }\n    get responseType() {\n        return this.responseType_;\n    }\n    set responseType(newResponseType) {\n        this.responseType_ = newResponseType;\n    }\n    get body() {\n        return this.body_;\n    }\n    set body(body) {\n        this.body_ = body;\n    }\n    get headers() {\n        return this.headers_;\n    }\n    setHeader(key, value) {\n        this.headers_.set(key, value);\n    }\n}\nclass HttpResponse {\n    constructor(request, status, headers, data, ok, message) {\n        this.message_ = '';\n        this.request_ = request;\n        this.status_ = status;\n        this.headers_ = headers;\n        this.data_ = data;\n        this.ok_ = ok;\n        this.message_ = message;\n    }\n    get request() {\n        return this.request_;\n    }\n    get status() {\n        return this.status_;\n    }\n    get headers() {\n        return this.headers_;\n    }\n    get data() {\n        return this.data_;\n    }\n    get ok() {\n        return this.ok_;\n    }\n    get message() {\n        return this.message_;\n    }\n}\nclass NetworkHandle {\n    static fetch(request) {\n        return new Promise((resolve, reject) => {\n            const xhr = new XMLHttpRequest();\n            xhr.open(request.method, request.url);\n            xhr.responseType = request.responseType;\n            request.headers.forEach((value, name) => {\n                xhr.setRequestHeader(name, value);\n            });\n            const makeResponse = (isOk) => {\n                return new HttpResponse(request, xhr.status, xhr.getAllResponseHeaders(), xhr.response, isOk, xhr.statusText);\n            };\n            xhr.onload = (ev) => {\n                const response = makeResponse((xhr.status >= 200 && xhr.status < 300));\n                if (response.ok) {\n                    resolve(response);\n                }\n                else {\n                    reject(response);\n                }\n            };\n            xhr.onerror = xhr.ontimeout = xhr.onabort = (ev) => {\n                reject(makeResponse(false));\n            };\n            xhr.send(request.body);\n        });\n    }\n}\n\n;// CONCATENATED MODULE: ./src/streamer.ts\nvar streamer_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n/**\n * The Streamer\n *\n * This class is responsible for streaming the media content by leveraging\n * the MSE APIs (via the MSE Adapter).\n */\nclass Streamer {\n    constructor(mseAdapter, presentation) {\n        this.mediaStates_ = new Map();\n        this.startTime_ = null;\n        this.stopped_ = false;\n        this.scheduleInterval = 0.25;\n        this.mse_ = mseAdapter;\n        this.presentation_ = presentation;\n    }\n    /**\n     * This method sets up the streamer. It needs to be called first!\n     * Upon call, it will open the media source and setup source buffers for\n     * streams in |streamMap|. Futhermore it will create an internal media state\n     * for each stream in |streamMap|; the media state keeps record of the\n     * stream's context the streamer needs to operate correctly.\n     *\n     * @param streamMap A map containing initial streams\n     * @returns Promise\n     */\n    setup(streamMap) {\n        return streamer_awaiter(this, void 0, void 0, function* () {\n            yield this.mse_.openMediaSource();\n            yield this.mse_.setupSourceBuffers(streamMap);\n            // Create media states\n            streamMap.forEach((stream, mediatType) => {\n                if (mediatType === MediaType.VIDEO) {\n                    if (!this.mediaStates_.has(mediatType)) {\n                        this.mediaStates_.set(mediatType, this.createMediaState_(mediatType, stream));\n                    }\n                }\n                if (mediatType === MediaType.AUDIO) {\n                    if (!this.mediaStates_.has(mediatType)) {\n                        this.mediaStates_.set(mediatType, this.createMediaState_(mediatType, stream));\n                    }\n                }\n            });\n            // This operation is successful is we could setup all streams.\n            console.assert(streamMap.size === this.mediaStates_.size, 'Should have media states for all types');\n            // Set duration\n            const stream = streamMap.get(MediaType.VIDEO) || streamMap.get(MediaType.AUDIO);\n            // TODO - Add getDuration() to IPresentation\n            let duration = stream === null || stream === void 0 ? void 0 : stream.segmentIndex.getEndTime();\n            if (!duration) {\n                throw new Error('Could not set stream duration!');\n            }\n            if (this.presentation_.isLive()) {\n                duration = Number.MAX_SAFE_INTEGER;\n            }\n            this.mse_.setDuration(duration);\n        });\n    }\n    /**\n     * Start the streaming. At this point the media source and source buffers\n     * are set. This method will set the stream start time and active\n     * the schedule timer for each media state.\n     *\n     * @returns True if successful, false otherwise.\n     */\n    start() {\n        if (this.mediaStates_.size === 0) {\n            console.warn('Streams needs to be setup before start. No-op...');\n            return false;\n        }\n        if (this.startTime_) {\n            console.warn('Streaming already started...');\n            return false;\n        }\n        this.stopped_ = false;\n        this.startTime_ = 0;\n        // For live stream calculate 'tune-in' time.\n        if (this.presentation_.isLive()) {\n            const presentationDelay = this.presentation_.getDelay();\n            this.startTime_ = Math.max(0, this.getLiveEdge_() - presentationDelay);\n        }\n        const mediaState = this.mediaStates_.get(MediaType.VIDEO) ||\n            this.mediaStates_.get(MediaType.AUDIO);\n        console.assert(mediaState === null || mediaState === void 0 ? void 0 : mediaState.stream.segmentIndex.hasTime(this.startTime_), 'Bug: Start time is not within the presentation timeline');\n        console.log('Start time:', this.startTime_);\n        // Set the start time\n        this.mse_.setCurrentTime(this.startTime_);\n        for (const mediaState of this.mediaStates_.values()) {\n            // Start streaming\n            this.onTick_(mediaState);\n            // Setup scheduler\n            mediaState.scheduleTimer = new Timer(() => this.onTick_(mediaState));\n            mediaState.scheduleTimer.tickEvery(this.scheduleInterval);\n        }\n        return true;\n    }\n    /**\n     * Stop streaming.\n     */\n    stop() {\n        var _a;\n        this.stopped_ = true;\n        this.mse_.closeMediaSource();\n        for (const mediaState of this.mediaStates_.values()) {\n            (_a = mediaState.scheduleTimer) === null || _a === void 0 ? void 0 : _a.clear();\n            mediaState.updating = false;\n        }\n    }\n    /**\n     * @returns The presentation time we started streaming at\n     */\n    getStartTime() {\n        return this.startTime_;\n    }\n    /**\n     * Get the stream of type |mediaType| being currently buffered\n     *\n     * @param mediaType The media type\n     * @returns The active |mediaType| stream or null\n     */\n    getActiveStream(mediaType) {\n        const mediaState = this.mediaStates_.get(mediaType);\n        if (mediaState) {\n            return mediaState.stream;\n        }\n        return null;\n    }\n    /**\n     * Called when a stream's scheduler timer ticked. This will check, for an\n     * idling stream, if there is a segment to download in which case\n     * |fetchAndAppend_()| will be called to perform the actually download\n     * and push the data to the source buffer (via the MSE adapter).\n     *\n     * @param mediaState The media state of the currently scheduled stream.\n     * @returns Promise.\n     */\n    onTick_(mediaState) {\n        return streamer_awaiter(this, void 0, void 0, function* () {\n            if (this.stopped_) {\n                // Streaming has been stopped\n                return;\n            }\n            if (mediaState.updating) {\n                // Media state is still updating\n                return;\n            }\n            // Check if we should buffer more\n            const bufferingGoal = 30;\n            const playheadPosition = this.presentation_.getPosition();\n            const bufferedAhead = this.mse_.getBufferedAheadOf(mediaState.type, playheadPosition);\n            if (bufferedAhead > bufferingGoal) {\n                return;\n            }\n            mediaState.updating = true;\n            try {\n                let timeNeeded = this.getTimeNeeded_(mediaState);\n                const nextSegment = mediaState.stream.segmentIndex.find(timeNeeded);\n                if (nextSegment) {\n                    if (mediaState.needInit) {\n                        const initSegment = mediaState.stream.initialization;\n                        yield this.fetchAndAppend_(mediaState, initSegment);\n                    }\n                    yield this.fetchAndAppend_(mediaState, nextSegment);\n                    mediaState.lastSegment = nextSegment;\n                }\n            }\n            catch (e) {\n                const netRespone = e;\n                if (netRespone.status && netRespone.status === 404) {\n                    console.info('Segment present in manifest but server returned HTTP 404.', 'Will rety...');\n                }\n                else {\n                    console.error('(streaming) Fetch and append failed...', e);\n                    // throw e;\n                }\n            }\n            finally {\n                mediaState.updating = false;\n            }\n        });\n    }\n    /**\n     * Fetch segment and push data to buffer.\n     *\n     * @param mediaState The stream's state/context.\n     * @param segment The segment to download.\n     */\n    fetchAndAppend_(mediaState, segment) {\n        return streamer_awaiter(this, void 0, void 0, function* () {\n            const request = new HttpRequest(segment.url);\n            request.responseType = 'arraybuffer';\n            const response = yield NetworkHandle.fetch(request);\n            yield this.mse_.appendBuffer(mediaState.type, response.data);\n            if (segment.isInit) {\n                mediaState.needInit = false;\n            }\n        });\n    }\n    /**\n     * Get next timestamp we need to buffer.\n     *\n     * @param mediaState The stream state/context.\n     * @returns The time needed.\n     */\n    getTimeNeeded_(mediaState) {\n        if (mediaState.lastSegment) {\n            return mediaState.lastSegment.end;\n        }\n        return this.presentation_.getPosition();\n    }\n    /**\n     * Computes the live edge.\n     * @returns The live edge\n     */\n    getLiveEdge_() {\n        console.assert(this.presentation_.isLive(), 'Invalid call to getLiveEdge_()');\n        const maxSegmentDuration = this.presentation_.getMaxSegmentDuration();\n        const presentationStartTime = this.presentation_.getStartTime();\n        const now = Date.now() / 1000;\n        return Math.max(0, now - maxSegmentDuration - presentationStartTime);\n    }\n    createMediaState_(type, stream) {\n        return {\n            type,\n            stream,\n            needInit: true,\n            lastSegment: null,\n            updating: false,\n            scheduleTimer: null\n        };\n    }\n}\n\n;// CONCATENATED MODULE: ./src/dash/segment-index.ts\n/**\n * Creates a segment index.\n */\nclass SegmentIndex {\n    constructor(segments) {\n        this.segments_ = segments;\n    }\n    /**\n     * Get All segments in this index.\n     * @returns All segments in the index.\n     */\n    getSegments() {\n        return this.segments_;\n    }\n    /**\n     * Add new segment to the index.\n     * @param newSegments\n     */\n    merge(newSegments) {\n        if (newSegments.length < 1) {\n            return;\n        }\n        const currentEndTime = this.getEndTime(true);\n        // console.log('Current timeline end:', currentEndTime);\n        // Extend current index with new segments\n        for (let i = 0; i < newSegments.length; i++) {\n            const newSegment = newSegments[i];\n            if (newSegment.unscaledStart >= currentEndTime) {\n                this.segments_.push(newSegment);\n                // console.log(\n                //   'Added new segment to index. Start:', newSegment.unscaledStart,\n                //   'End:', (newSegment.unscaledStart + newSegment.unscaledDuration));\n            }\n        }\n        if (!this.isContiguous(this.segments_)) {\n            console.warn('The segment timeline is not contiguous. ' +\n                'This might lead to playback issues');\n        }\n    }\n    /**\n     * Search the index for a segment that contains the providedn |time|.\n     *\n     * @param time\n     * @returns The segment that contains |time| or null.\n     */\n    find(time) {\n        for (const segment of this.segments_) {\n            if ((segment.start <= time) && (time < segment.end)) {\n                return segment;\n            }\n        }\n        console.warn('Could not find segment for time:' + time + '.', 'Segment count: ' + (this.segments_.length - 1), 'Last end: ' + this.getEndTime());\n        return null;\n    }\n    /**\n     * Get the index start time.\n     *\n     * @param unscaled Whether or not the return the unscaled time\n     * @returns Start time.\n     */\n    getStartTime(unscaled) {\n        if (this.segments_.length > 0) {\n            const first = this.segments_[this.segments_.length - 1];\n            return (unscaled ? first.start : first.unscaledStart);\n        }\n        return 0;\n    }\n    /**\n     * Get the index end time.\n     *\n     * @param unscaled Whether or not the return the unscaled time\n     * @returns End time.\n     */\n    getEndTime(unscaled) {\n        if (this.segments_.length > 0) {\n            const last = this.segments_[this.segments_.length - 1];\n            return unscaled ? last.unscaledEnd : last.end;\n        }\n        return 0;\n    }\n    /**\n     * Evicts segment from the index, that have fallen out of the provided\n     * window length.\n     *\n     * @param dvrWindowLength DVR window length\n     */\n    adjustDvrWindow(dvrWindowLength) {\n        const windowStart = this.getEndTime() - dvrWindowLength;\n        const oldSize = this.segments_.length;\n        this.segments_ =\n            this.segments_.filter(segment => segment.end > windowStart);\n        const newSize = this.segments_.length;\n        console.log('Evicted ' + (oldSize - newSize) + ' segments.');\n    }\n    /**\n     * Checks if the provided media segments constitute a contiguous timeline.\n     *\n     * @param segments Array of media segments\n     * @returns True if timeline is contiguous, false otherwise.\n     */\n    isContiguous(segments) {\n        if (segments.length < 2) {\n            return true;\n        }\n        for (let i = 1; i < segments.length; i++) {\n            const prev = segments[i - 1];\n            const curr = segments[i];\n            const prevEnd = prev.unscaledStart + prev.unscaledDuration;\n            if (curr.unscaledStart - prevEnd !== 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Check if the timeline formed by the segments currently in the index\n     * includes the provided |time|.\n     * @param time Time to check\n     * @returns True if |time| in segment timeline.\n     */\n    hasTime(time) {\n        const firstSegment = this.segments_[0];\n        const lastSegment = this.segments_[this.segments_.length - 1];\n        const firstSegmentStart = firstSegment.start;\n        const lastSegmentEnd = lastSegment.end;\n        return (firstSegmentStart <= time) && (time <= lastSegmentEnd);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/dash/manifest-parser.ts\nvar manifest_parser_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n/**\n * A MPEG-DASH Manifest parser.\n *\n * The parser is tailored to consume Zattoo Live stream with respect of the\n * scope of the case study. MPEG-DASH feature beyond the scope of the case\n * study may not be supported.\n */\nclass ManifestParser {\n    constructor() {\n        this.manifestUrl_ = '';\n        this.manifest_ = null;\n        this.maxSegmentDuration_ = -1;\n        this.presentationDuration_ = null;\n        this.streamMap_ = new Map();\n        this.globalId_ = 0;\n        this.refreshTimer_ = new Timer(() => this.refreshManifest_());\n    }\n    /**\n     * Starts the parser. This method will load and parse the manifest.\n     *\n     * @param manifestUrl The manifest URL\n     * @returns Promise containing the parsed manifest.\n     */\n    start(manifestUrl) {\n        return manifest_parser_awaiter(this, void 0, void 0, function* () {\n            console.log('Manifest parser starts...');\n            this.manifestUrl_ = manifestUrl;\n            this.manifest_ = yield this.loadAndParseManifest_();\n            if (this.manifest_.type === StreamType.LIVE) {\n                this.refreshTimer_.tickAfter(this.manifest_.minUpdatePeriod);\n            }\n            return this.manifest_;\n        });\n    }\n    /**\n     * Stop parsing.\n     */\n    stop() {\n        return manifest_parser_awaiter(this, void 0, void 0, function* () {\n            console.log('Manifest parser stops...');\n            this.refreshTimer_.clear();\n            this.globalId_ = 0;\n            this.streamMap_.clear();\n            this.maxSegmentDuration_ = -1;\n        });\n    }\n    loadAndParseManifest_() {\n        return manifest_parser_awaiter(this, void 0, void 0, function* () {\n            let req = new HttpRequest(this.manifestUrl_);\n            req.responseType = 'text';\n            const respone = yield NetworkHandle.fetch(req);\n            const mpd = ParserUtils.parseXml(respone.data);\n            if (!mpd) {\n                throw new Error('Invalid Manifest');\n            }\n            this.presentationDuration_ =\n                ParserUtils.parseIsoDuration(mpd.getAttribute('mediaPresentationDuration') || '') || null;\n            const presentationType = mpd.getAttribute('type');\n            const minBufferTime = ParserUtils.parseIsoDuration(mpd.getAttribute('minBufferTime') || '') || -1;\n            const presentationStartTime = ParserUtils.parseDate(mpd.getAttribute('availabilityStartTime') || '') || 0;\n            const suggestedPresentationDelay = ParserUtils.parseIsoDuration(mpd.getAttribute('suggestedPresentationDelay') || '');\n            const minimumUpdatePeriod = ParserUtils.parseIsoDuration(mpd.getAttribute('minimumUpdatePeriod') || '') || -1;\n            const dvrWindowLength = ParserUtils.parseIsoDuration(mpd.getAttribute('timeShiftBufferDepth') || '') || Infinity;\n            let presentationDelay = null;\n            const periodNodes = ParserUtils.getChildren(mpd, 'Period');\n            if (periodNodes.length === 0) {\n                console.error('No period found');\n                throw new Error('Invalid manifest: no period found');\n            }\n            if (periodNodes.length > 1) {\n                console.warn('Multi-period manifests not supported. ' +\n                    'Additional periods will be ignored...');\n            }\n            // Multi-period not supported yet!\n            const period = periodNodes[0];\n            const periodDuration = ParserUtils.parseIsoDuration(period.getAttribute('duration') || '') || null;\n            if (!this.presentationDuration_) {\n                if (periodDuration) {\n                    this.presentationDuration_ = periodDuration;\n                }\n                else if (presentationType === 'dynamic') {\n                    this.presentationDuration_ = Number.MAX_SAFE_INTEGER;\n                }\n            }\n            if (!this.presentationDuration_) {\n                throw new Error('Could not determine presentation duration!');\n            }\n            // TODO - Period might contain segment infos\n            const adaptationSetNodes = ParserUtils.getChildren(period, 'AdaptationSet');\n            adaptationSetNodes.forEach(this.parseAdaptationSet_.bind(this));\n            if (suggestedPresentationDelay) {\n                presentationDelay = suggestedPresentationDelay;\n            }\n            else {\n                console.assert(this.maxSegmentDuration_ > 0, 'Bug: Should have set max segment duration!');\n                presentationDelay = Math.round(this.maxSegmentDuration_ * 3);\n            }\n            const manifest = {\n                type: presentationType === 'dynamic' ? StreamType.LIVE : StreamType.VOD,\n                startTime: presentationStartTime,\n                delay: presentationDelay,\n                duration: this.presentationDuration_,\n                dvrWindowLength,\n                minBufferTime,\n                minUpdatePeriod: minimumUpdatePeriod,\n                maxSegmentDuration: this.maxSegmentDuration_,\n                video: this.streamMap_.get(MediaType.VIDEO) || [],\n                audio: this.streamMap_.get(MediaType.AUDIO) || []\n            };\n            // We done parsing clear stream map\n            this.streamMap_.clear();\n            return manifest;\n        });\n    }\n    parseAdaptationSet_(elem) {\n        const id = elem.getAttribute('id') || String(this.globalId_++);\n        const mimeType = elem.getAttribute('mimeType') || '';\n        const codecs = elem.getAttribute('codecs') || '';\n        const contentType = elem.getAttribute('contentType') || ParserUtils.getTypeFromMimeType(mimeType);\n        const segmentTemplate = ParserUtils.getFirstChild(elem, 'SegmentTemplate');\n        const segmentBase = ParserUtils.getFirstChild(elem, 'SegmentBase');\n        const segmentList = ParserUtils.getFirstChild(elem, 'SegmentList');\n        // We only parse video and audio streams!\n        if (contentType !== MediaType.VIDEO && contentType !== MediaType.AUDIO) {\n            return;\n        }\n        if (segmentBase || segmentList) {\n            console.warn('Currently only SegmentTemplate is supported!');\n            return;\n        }\n        if (!segmentTemplate) {\n            console.error('No support for manifest type!');\n            throw new Error('Only DASH manifest with segment template are supported!');\n        }\n        if (this.streamMap_.has(contentType)) {\n            console.warn('Multiple adaptation sets for same content type is not supported...');\n            return;\n        }\n        const representationNodes = ParserUtils.getChildren(elem, 'Representation');\n        const streams = [];\n        for (const representationNode of representationNodes) {\n            const context = {\n                id,\n                mimeType,\n                contentType,\n                codecs,\n                segmentTemplate\n            };\n            const parsed = this.parseRepresentation_(representationNode, context);\n            if (parsed) {\n                streams.push(parsed);\n            }\n        }\n        if (streams.length < 1) {\n            console.error('Empty AdaptationSet!');\n            throw new Error(`Invalid manifest: no represenation found for ${contentType}`);\n        }\n        this.streamMap_.set(contentType, streams);\n    }\n    parseRepresentation_(elem, context) {\n        const originalId = elem.getAttribute('id') || '';\n        const bandwidth = Number(elem.getAttribute('bandwidth'));\n        const width = Number(elem.getAttribute('width'));\n        const height = Number(elem.getAttribute('height'));\n        const codecs = elem.getAttribute('codecs') || context.codecs;\n        const frameRate = Number(elem.getAttribute('frameRate'));\n        const segmentTemplate = ParserUtils.getFirstChild(elem, 'SegmentTemplate') || context.segmentTemplate;\n        const rContext = {\n            id: originalId,\n            bandwidth,\n            adaptationSet: context\n        };\n        const mediaData = this.parseSegmentTemplate_(segmentTemplate, rContext);\n        console.assert(mediaData.mediaSegments.length > 0, 'Should have parsed segments');\n        return {\n            // TODO\n            id: context.contentType + '_' + context.id + '_' + (originalId ? originalId : String(this.globalId_++)),\n            originalId,\n            type: context.contentType,\n            kbps: bandwidth / 1000,\n            width,\n            height,\n            frameRate,\n            codecs,\n            mimeType: context.mimeType,\n            initialization: mediaData.initSegment,\n            segmentIndex: new SegmentIndex(mediaData.mediaSegments)\n        };\n    }\n    parseSegmentTemplate_(elem, context) {\n        // Section 5.3.9.2.2\n        const presentationTimeOffset = Number(elem.getAttribute('presentationTimeOffset'));\n        const timescale = Number(elem.getAttribute('timescale')) || 1;\n        const segmentDuration = Number(elem.getAttribute('duration')) || -1;\n        const initialization = elem.getAttribute('initialization') || '';\n        const media = elem.getAttribute('media') || '';\n        const startNumber = Number(elem.getAttribute('startNumber')) || 1;\n        const segmentTimeline = ParserUtils.getFirstChild(elem, 'SegmentTimeline');\n        const mContext = {\n            startNumber,\n            segmentDuration,\n            timeOffset: presentationTimeOffset,\n            timescale,\n            initializationAttr: initialization,\n            mediaAttr: media,\n            representation: context\n        };\n        // Segment template with timeline.\n        if (segmentTimeline) {\n            return this.createSegmentsFromTimeline_(segmentTimeline, mContext);\n        }\n        return this.createSegmentsFromTemplate_(mContext);\n    }\n    createSegmentsFromTemplate_(context) {\n        console.assert(context.segmentDuration > 0, 'Segment template without timeline should have segment duration');\n        if (!this.presentationDuration_) {\n            throw new Error('Missing presentation duration!');\n        }\n        const segments = [];\n        let position = context.startNumber;\n        let scaledSegmentDuration = context.segmentDuration / context.timescale;\n        let start = 0;\n        let end = scaledSegmentDuration;\n        // TODO\n        this.maxSegmentDuration_ = end - start;\n        while (end < this.presentationDuration_) {\n            const unscaledStart = start * context.timescale;\n            const unscaledEnd = end * context.timescale;\n            segments.push({\n                start,\n                end,\n                duration: end - start,\n                unscaledStart,\n                unscaledEnd,\n                unscaledDuration: unscaledEnd - unscaledStart,\n                isInit: false,\n                url: ParserUtils.resolveTemplateUrl(context.mediaAttr, {\n                    representationId: context.representation.id,\n                    bandwidth: context.representation.bandwidth,\n                    time: unscaledStart,\n                    number: position\n                }, this.manifestUrl_)\n            });\n            start = end;\n            end = Math.min(this.presentationDuration_, (end + scaledSegmentDuration));\n            ++position;\n        }\n        console.assert(segments.length > 0, 'Should have segments!!!');\n        return {\n            initSegment: {\n                start: 0,\n                end: 0,\n                duration: 0,\n                unscaledStart: 0,\n                unscaledEnd: 0,\n                unscaledDuration: 0,\n                isInit: true,\n                url: ParserUtils.resolveTemplateUrl(context.initializationAttr, // Init Url template\n                {\n                    representationId: context.representation.id,\n                    bandwidth: context.representation.bandwidth\n                }, this.manifestUrl_)\n            },\n            mediaSegments: segments\n        };\n    }\n    createSegmentsFromTimeline_(elem, context) {\n        // Section 5.3.9.6\n        const sNodes = ParserUtils.getChildren(elem, 'S');\n        const mediaSegments = [];\n        for (const sNode of sNodes) {\n            let d = Number(sNode.getAttribute('d'));\n            let r = Number(sNode.getAttribute('r'));\n            let t = null;\n            let scaledT = null;\n            let scaledD = d / context.timescale;\n            // TODO - Assert has duration\n            if (sNode.hasAttribute('t')) {\n                t = Number(sNode.getAttribute('t')) - context.timeOffset;\n            }\n            else if (mediaSegments.length === 0) {\n                // If @t not present, then the value shall be assumed zero for the\n                // first S element.\n                t = 0;\n            }\n            else {\n                // If @t not present, and not the first S element then the value\n                // shall be assumed to be the sum of the previous S element's earliest\n                // presentation time and contiguous duration i.e. end time for previous\n                // segment.\n                const lastSegment = mediaSegments[mediaSegments.length - 1];\n                t = lastSegment.unscaledStart + lastSegment.unscaledDuration;\n            }\n            const unscaledEnd = t + d;\n            scaledT = t / context.timescale;\n            // TODO - Check for discontinuity\n            if (this.maxSegmentDuration_ < scaledD) {\n                this.maxSegmentDuration_ = scaledD;\n            }\n            mediaSegments.push({\n                start: scaledT,\n                end: unscaledEnd / context.timescale,\n                duration: scaledD,\n                unscaledStart: t,\n                unscaledEnd,\n                unscaledDuration: d,\n                isInit: false,\n                url: ParserUtils.resolveTemplateUrl(context.mediaAttr, // url template\n                { bandwidth: context.representation.bandwidth, time: t }, this.manifestUrl_)\n            });\n            if (r < -1) {\n                console.warn('Negative repeat count not supported at the moment');\n            }\n            if (r > 0) {\n                for (let i = 0; i <= r; i++) {\n                    const lastSegment = mediaSegments[mediaSegments.length - 1];\n                    const nextStartUnscaled = lastSegment.unscaledEnd;\n                    const nextEndUnscaled = nextStartUnscaled + d;\n                    mediaSegments.push({\n                        start: lastSegment.end,\n                        end: nextEndUnscaled / context.timescale,\n                        duration: scaledD,\n                        unscaledStart: nextStartUnscaled,\n                        unscaledEnd: nextEndUnscaled,\n                        unscaledDuration: d,\n                        isInit: false,\n                        url: ParserUtils.resolveTemplateUrl(context.mediaAttr, {\n                            bandwidth: context.representation.bandwidth,\n                            time: nextStartUnscaled\n                        }, this.manifestUrl_)\n                    });\n                }\n            }\n        }\n        return {\n            initSegment: {\n                start: 0,\n                end: 0,\n                duration: 0,\n                unscaledStart: 0,\n                unscaledEnd: 0,\n                unscaledDuration: 0,\n                isInit: true,\n                url: ParserUtils.resolveTemplateUrl(context.initializationAttr, // Init Url template\n                {\n                    representationId: context.representation.id,\n                    bandwidth: context.representation.bandwidth\n                }, this.manifestUrl_)\n            },\n            mediaSegments\n        };\n    }\n    refreshManifest_() {\n        return manifest_parser_awaiter(this, void 0, void 0, function* () {\n            if (!this.manifest_)\n                return;\n            console.log('Refreshing manifest...');\n            try {\n                const newManifest = yield this.loadAndParseManifest_();\n                // TODO\n                this.manifest_.dvrWindowLength = newManifest.dvrWindowLength;\n                this.manifest_.minUpdatePeriod = newManifest.minUpdatePeriod;\n                // Update streams\n                if (this.manifest_.video && newManifest.video) {\n                    this.updateStreams_(this.manifest_.video, newManifest.video, this.manifest_.dvrWindowLength);\n                }\n                if (this.manifest_.audio && newManifest.audio) {\n                    this.updateStreams_(this.manifest_.audio, newManifest.audio, this.manifest_.dvrWindowLength);\n                }\n                // TODO: Notify new manifest?\n                // Schedule next update\n                this.refreshTimer_.tickAfter(this.manifest_.minUpdatePeriod);\n            }\n            catch (error) {\n                console.error('Failed to refresh manifest, retrying...', error);\n                // Retry\n                this.refreshTimer_.tickAfter(0);\n            }\n        });\n    }\n    updateStreams_(oldStreams, newStreams, dvrWindowLength) {\n        console.assert(oldStreams.length === newStreams.length, 'Stream count missmatch after manifest update!');\n        // TODO\n        // Improve the stream mapping. For simplicity sake we will assume, for\n        // now, that streams appears in each manifest in the same order and\n        // in the same amount i.e. we assume an 1:1 mapping with the new\n        // manifest.\n        for (let i = 0; i < oldStreams.length; i++) {\n            const newSegments = newStreams[i].segmentIndex.getSegments();\n            oldStreams[i].segmentIndex.merge(newSegments);\n            // Adjust DVR window\n            if (dvrWindowLength) {\n                oldStreams[i].segmentIndex.adjustDvrWindow(dvrWindowLength);\n            }\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./src/player.ts\nvar player_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n/**\n * A minimal MPEG-DASH player.\n */\nclass Player {\n    constructor(video) {\n        this.manifestUrl_ = '';\n        this.manifest_ = null;\n        this.parser_ = null;\n        this.mse_ = null;\n        this.streamer_ = null;\n        this.video_ = video;\n    }\n    /**\n     * Loads and play the provided content.\n     *\n     * @param streamUrl The content URL.\n     * @return Promise.\n     */\n    load(streamUrl) {\n        return player_awaiter(this, void 0, void 0, function* () {\n            this.manifestUrl_ = streamUrl;\n            this.parser_ = new ManifestParser();\n            this.mse_ = new MseAdapter(this.video_);\n            this.streamer_ = new Streamer(this.mse_, this.getPresentationImpl_());\n            this.manifest_ = yield this.parser_.start(this.manifestUrl_);\n            const initStreams = new Map();\n            initStreams.set(MediaType.VIDEO, this.pickHighestKbps_(this.manifest_.video));\n            initStreams.set(MediaType.AUDIO, this.pickHighestKbps_(this.manifest_.audio));\n            yield this.streamer_.setup(initStreams);\n            const streamingStarted = yield this.streamer_.start();\n            if (streamingStarted) {\n                this.video_.play();\n            }\n            else {\n                console.error('Could not start streaming!');\n                throw Error('Streaming Start failed');\n            }\n        });\n    }\n    /**\n     * Stops the player.\n     */\n    stop() {\n        return player_awaiter(this, void 0, void 0, function* () {\n            if (this.parser_) {\n                this.parser_.stop();\n                this.parser_ = null;\n            }\n            if (this.streamer_) {\n                this.streamer_.stop();\n            }\n            if (this.mse_) {\n                this.mse_ = null;\n            }\n        });\n    }\n    /**\n     * Get all video tracks.\n     * @returns All available video tracks\n     */\n    getAllVideo() {\n        if (this.manifest_ && this.manifest_.video.length > 0) {\n            return this.manifest_.video.map(video => this.getPublicVideo_(video));\n        }\n        return [];\n    }\n    /**\n     * Get all audio tracks.\n     * @returns All available audio tracks.\n     */\n    getAllAudio() {\n        if (this.manifest_ && this.manifest_.audio.length > 0) {\n            return this.manifest_.audio.map(audio => this.getPublicAudio_(audio));\n        }\n        return [];\n    }\n    /**\n     * Get the active (currently buffering) video stream.\n     * @returns The currently active video stream or null.\n     */\n    getActiveVideo() {\n        var _a;\n        const active = ((_a = this.streamer_) === null || _a === void 0 ? void 0 : _a.getActiveStream(MediaType.VIDEO)) || null;\n        if (active) {\n            return this.getPublicVideo_(active);\n        }\n        return active;\n    }\n    /**\n     * Get the active (currently buffering) audio stream.\n     * @returns The currently active audio stream or null.\n     */\n    getActiveAudio() {\n        var _a;\n        const active = ((_a = this.streamer_) === null || _a === void 0 ? void 0 : _a.getActiveStream(MediaType.AUDIO)) || null;\n        if (active) {\n            return this.getPublicAudio_(active);\n        }\n        return null;\n    }\n    isLive() {\n        if (this.manifest_ && this.manifest_.type === StreamType.LIVE) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @returns An implementation of IPresentation.\n     */\n    getPresentationImpl_() {\n        return {\n            isLive: () => this.isLive(),\n            getStartTime: () => (this.manifest_ && this.manifest_.startTime) || 0,\n            getMaxSegmentDuration: () => {\n                if (this.manifest_) {\n                    return this.manifest_.maxSegmentDuration;\n                }\n                return 0;\n            },\n            getDelay: () => {\n                if (this.manifest_) {\n                    return this.manifest_.delay;\n                }\n                return 0;\n            },\n            getPosition: () => this.video_.currentTime || 0,\n            getDuration: () => {\n                if (this.manifest_) {\n                    return this.manifest_.duration;\n                }\n                return 0;\n            }\n        };\n    }\n    pickHighestKbps_(streams) {\n        return streams.reduce((s1, s2) => (s1.kbps > s2.kbps) ? s1 : s2);\n    }\n    getPublicVideo_(video) {\n        return {\n            id: video.id,\n            originalId: video.originalId,\n            type: video.type,\n            kbps: video.kbps,\n            codecs: video.codecs,\n            mimeType: video.mimeType,\n            width: video.width,\n            height: video.height,\n            frameRate: video.frameRate\n        };\n    }\n    getPublicAudio_(audio) {\n        return {\n            id: audio.id,\n            originalId: audio.originalId,\n            type: audio.type,\n            kbps: audio.kbps,\n            codecs: audio.codecs,\n            mimeType: audio.mimeType\n        };\n    }\n}\n\n;// CONCATENATED MODULE: ./src/index.ts\n\nconst lib = {\n    Player: Player\n};\n/* harmony default export */ const src = (lib);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3JDLENBQUM7SUFDSixDQUFDO0lBR08sZUFBZSxDQUFFLEtBQXNCO1FBQzdDLE9BQU87WUFDTCxFQUFFLEVBQUUsS0FBSyxDQUFDLEVBQUU7WUFDWixVQUFVLEVBQUUsS0FBSyxDQUFDLFVBQVU7WUFDNUIsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJO1lBQ2hCLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSTtZQUNoQixNQUFNLEVBQUUsS0FBSyxDQUFDLE1BQU07WUFDcEIsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRO1NBQ3pCLENBQUM7SUFDSixDQUFDO0NBQ0Y7OztBQzdNaUM7QUFFbEMsTUFBTSxHQUFHLEdBQUc7SUFDVixNQUFNO0NBQ1AsQ0FBQztBQUVGLDBDQUFlLEdBQUcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3lvZGEvLi9zcmMvZGFzaC90eXBlcy50cz9kN2Y5Iiwid2VicGFjazovL3lvZGEvLi9zcmMvZGFzaC9wYXJzZXItdXRpbHMudHM/NmI5MiIsIndlYnBhY2s6Ly95b2RhLy4vc3JjL3V0aWxzL2FzeW5jLXRhc2sudHM/NmEwYSIsIndlYnBhY2s6Ly95b2RhLy4vc3JjL3V0aWxzL3RpbWUtcmFuZ2VzLnRzP2M3ZGUiLCJ3ZWJwYWNrOi8veW9kYS8uL3NyYy9tc2UtYWRhcHRlci50cz8zYTJmIiwid2VicGFjazovL3lvZGEvLi9zcmMvdXRpbHMvdGltZXIudHM/MjhkNCIsIndlYnBhY2s6Ly95b2RhLy4vc3JjL3V0aWxzL25ldHdvcmsudHM/ODEzYSIsIndlYnBhY2s6Ly95b2RhLy4vc3JjL3N0cmVhbWVyLnRzPzgwYjIiLCJ3ZWJwYWNrOi8veW9kYS8uL3NyYy9kYXNoL3NlZ21lbnQtaW5kZXgudHM/MGU5ZCIsIndlYnBhY2s6Ly95b2RhLy4vc3JjL2Rhc2gvbWFuaWZlc3QtcGFyc2VyLnRzPzU2OWUiLCJ3ZWJwYWNrOi8veW9kYS8uL3NyYy9wbGF5ZXIudHM/YjlkZSIsIndlYnBhY2s6Ly95b2RhLy4vc3JjL2luZGV4LnRzP2ZmYjQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGludGVyZmFjZSBJU2VnbWVudCB7XG4gIHN0YXJ0OiBudW1iZXI7XG4gIGVuZDogbnVtYmVyO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICB1bnNjYWxlZFN0YXJ0OiBudW1iZXI7XG4gIHVuc2NhbGVkRW5kOiBudW1iZXI7XG4gIHVuc2NhbGVkRHVyYXRpb246IG51bWJlcjtcbiAgaXNJbml0OiBib29sZWFuO1xuICB1cmw6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUmVwcmVzZW50YXRpb24ge1xuICBpZDogc3RyaW5nO1xuICBvcmlnaW5hbElkOiBzdHJpbmc7XG4gIHR5cGU6IE1lZGlhVHlwZTtcbiAga2JwczogbnVtYmVyO1xuICB3aWR0aDogbnVtYmVyIHwgbnVsbDtcbiAgaGVpZ2h0OiBudW1iZXIgfCBudWxsO1xuICBmcmFtZVJhdGU6IG51bWJlciB8IG51bGw7XG4gIGNvZGVjczogc3RyaW5nO1xuICBtaW1lVHlwZTogc3RyaW5nO1xuICBpbml0aWFsaXphdGlvbjogSVNlZ21lbnQ7XG4gIHNlZ21lbnRJbmRleDogSVNlZ21lbnRJbmRleDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWFuaWZlc3Qge1xuICB0eXBlOiBTdHJlYW1UeXBlO1xuICBzdGFydFRpbWU6IG51bWJlcjtcbiAgZGVsYXk6IG51bWJlcjtcbiAgZHVyYXRpb246IG51bWJlcjtcbiAgZHZyV2luZG93TGVuZ3RoOiBudW1iZXI7XG4gIG1pbkJ1ZmZlclRpbWU6IG51bWJlcjtcbiAgbWluVXBkYXRlUGVyaW9kOiBudW1iZXI7XG4gIG1heFNlZ21lbnREdXJhdGlvbjogbnVtYmVyO1xuICB2aWRlbzogSVJlcHJlc2VudGF0aW9uW107XG4gIGF1ZGlvOiBJUmVwcmVzZW50YXRpb25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWFuaWZlc3RQYXJzZXIge1xuICBzdGFydCAobWFuaWZlc3RVcmw6IHN0cmluZykgOiBQcm9taXNlPElNYW5pZmVzdD47XG4gIHN0b3AgKCkgOiBQcm9taXNlPHZvaWQ+O1xufVxuXG5leHBvcnQgZW51bSBNZWRpYVR5cGUge1xuICBWSURFTyA9ICd2aWRlbycsXG4gIEFVRElPID0gJ2F1ZGlvJ1xufVxuXG5leHBvcnQgZW51bSBTdHJlYW1UeXBlIHsgTElWRSwgVk9EIH1cblxuZXhwb3J0IGludGVyZmFjZSBJU2VnbWVudEluZGV4IHtcbiAgZ2V0U2VnbWVudHMgKCkgOiBJU2VnbWVudFtdO1xuICBtZXJnZSAobmV3U2VnbWVudHM6IElTZWdtZW50W10pIDogdm9pZDtcbiAgZmluZCAodGltZTogbnVtYmVyKSA6IElTZWdtZW50IHwgbnVsbDtcbiAgZ2V0U3RhcnRUaW1lICh1bnNjYWxlZD86IGJvb2xlYW4pIDogbnVtYmVyO1xuICBnZXRFbmRUaW1lICh1bnNjYWxlZD86IGJvb2xlYW4pIDogbnVtYmVyO1xuICBhZGp1c3REdnJXaW5kb3cgKGR2cldpbmRvd0xlbmd0aDogbnVtYmVyKSA6IHZvaWQ7XG4gIGlzQ29udGlndW91cyAoc2VnbWVudHM6IElTZWdtZW50W10pIDogYm9vbGVhbjtcbiAgaGFzVGltZSAodGltZTogbnVtYmVyKSA6IGJvb2xlYW47XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBJUHJlc2VudGF0aW9uIHtcbiAgaXNMaXZlICgpIDogYm9vbGVhbjtcbiAgZ2V0U3RhcnRUaW1lICgpIDogbnVtYmVyO1xuICBnZXRNYXhTZWdtZW50RHVyYXRpb24gKCk6IG51bWJlcjtcbiAgZ2V0RGVsYXkgKCkgOiBudW1iZXI7XG4gIGdldFBvc2l0aW9uICgpIDogbnVtYmVyO1xuICBnZXREdXJhdGlvbiAoKSA6IG51bWJlcjtcbn1cbiIsImltcG9ydCB7IElSZXByZXNlbnRhdGlvbiB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbnR5cGUgVXJsVGVtcGxhdGVJZGVudGlmaWVyID0ge1xuICByZXByZXNlbnRhdGlvbklkOiBzdHJpbmc7IC8vICRSZXByZXNlbnRhdGlvbklEJFxuICBudW1iZXI6IG51bWJlcjsgICAgICAgICAgIC8vICROdW1iZXIkXG4gIGJhbmR3aWR0aDogbnVtYmVyOyAgICAgICAgLy8gJEJhbmR3aWR0aCRcbiAgdGltZTogbnVtYmVyOyAgICAgICAgICAgICAvLyAkVGltZSRcbiAgc3ViTnVtYmVyOiBudW1iZXI7ICAgICAgICAvLyAkU3ViTnVtYmVyJFxufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IG1ldGhvZHMgdG8gcGFyc2UgTVBFRy1EQVNIIG1hbmlmZXN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnNlclV0aWxzIHtcblxuICBzdGF0aWMgcGFyc2VYbWwgKGRhdGE6IHN0cmluZykgOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgbGV0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICBsZXQgeG1sID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhkYXRhLCAndGV4dC94bWwnKTtcblxuICAgIGlmICh4bWwgJiYgeG1sLmRvY3VtZW50RWxlbWVudC50YWdOYW1lID09PSAnTVBEJykge1xuICAgICAgcmV0dXJuIHhtbC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIHN0YXRpYyBnZXRDaGlsZHJlbiAobm9kZTogTm9kZSwgdGFnTmFtZTogc3RyaW5nKSA6IEVsZW1lbnRbXSB7XG4gICAgY29uc3QgY2hpbGRFbGVtZW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGNoaWxkLnRhZ05hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgY2hpbGRFbGVtZW50cy5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkRWxlbWVudHM7XG4gIH1cblxuXG4gIHN0YXRpYyBnZXRGaXJzdENoaWxkIChub2RlOiBOb2RlLCB0YWdOYW1lOiBzdHJpbmcpIDogRWxlbWVudCB8IG51bGwge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gUGFyc2VyVXRpbHMuZ2V0Q2hpbGRyZW4obm9kZSwgdGFnTmFtZSk7XG4gICAgcmV0dXJuIGNoaWxkcmVuPy5bMF0gfHwgbnVsbDtcbiAgfVxuXG5cbiAgc3RhdGljIHBhcnNlSXNvRHVyYXRpb24gKGR1cmF0aW9uU3RyaW5nOiBzdHJpbmcpIDogbnVtYmVyIHwgbnVsbCB7XG4gICAgY29uc3Qgc2Vjb25kc0luWWVhciA9IDM2NSAqIDI0ICogNjAgKiA2MDtcbiAgICBjb25zdCBzZWNvbmRzSW5Nb250aCA9IDMwICogMjQgKiA2MCAqIDYwO1xuICAgIGNvbnN0IHNlY29uZHNJbkRheSA9IDI0ICogNjAgKiA2MDtcbiAgICBjb25zdCBzZWNvbmRzSW5Ib3VyID0gNjAgKiA2MDtcbiAgICBjb25zdCBzZWNvbmRzSW5NaW51dGUgPSA2MDtcblxuICAgIGlmICghZHVyYXRpb25TdHJpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZ2V4ID0gL14oWy1dKT9QKChbXFxkLl0qKVkpPygoW1xcZC5dKilNKT8oKFtcXGQuXSopRCk/VD8oKFtcXGQuXSopSCk/KChbXFxkLl0qKU0pPygoW1xcZC5dKilTKT8vO1xuICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhkdXJhdGlvblN0cmluZyk7XG5cbiAgICBsZXQgZHVyYXRpb24gPSAocGFyc2VGbG9hdChtYXRjaD8uWzJdIHx8ICcwJykgKiBzZWNvbmRzSW5ZZWFyICtcbiAgICAgICAgcGFyc2VGbG9hdChtYXRjaD8uWzRdIHx8ICcwJykgKiBzZWNvbmRzSW5Nb250aCArXG4gICAgICAgIHBhcnNlRmxvYXQobWF0Y2g/Lls2XSB8fCAnMCcpICogc2Vjb25kc0luRGF5ICtcbiAgICAgICAgcGFyc2VGbG9hdChtYXRjaD8uWzhdIHx8ICcwJykgKiBzZWNvbmRzSW5Ib3VyICtcbiAgICAgICAgcGFyc2VGbG9hdChtYXRjaD8uWzEwXSB8fCAnMCcpICogc2Vjb25kc0luTWludXRlICtcbiAgICAgICAgcGFyc2VGbG9hdChtYXRjaD8uWzEyXSB8fCAnMCcpKTtcblxuICAgIGlmICh0eXBlb2YgbWF0Y2g/LlsxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGR1cmF0aW9uID0gLWR1cmF0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxuXG5cbiAgc3RhdGljIHBhcnNlRGF0ZSAoZGF0ZVN0cmluZzogc3RyaW5nKSA6IG51bWJlciB8IG51bGwge1xuICAgIGlmICghZGF0ZVN0cmluZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRvIHVzZSBVVEMgdGltZSBpbnN0ZWFkIG9mIGxvY2FsIHRpbWUgem9uZVxuICAgIGlmICghZGF0ZVN0cmluZy5lbmRzV2l0aCgnWicpKSB7XG4gICAgICBkYXRlU3RyaW5nICs9ICdaJztcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBEYXRlLnBhcnNlKGRhdGVTdHJpbmcpO1xuICAgIHJldHVybiAoIWlzTmFOKHJlc3VsdCkgPyBNYXRoLmZsb29yKHJlc3VsdCAvIDEwMDAuMCkgOiBudWxsKTtcbiAgfVxuXG5cbiAgc3RhdGljIHJlc29sdmVUZW1wbGF0ZVVybCAoXG4gICAgICB1cmw6IHN0cmluZyxcbiAgICAgIGlkZW50aWZpZXJzOiBQYXJ0aWFsPFVybFRlbXBsYXRlSWRlbnRpZmllcj4sXG4gICAgICBiYXNlVXJsPzogc3RyaW5nKSA6IHN0cmluZyB7XG5cbiAgICBsZXQgcmVzb2x2ZWRUZW1wbGF0ZSA9IHVybDtcblxuICAgIGlmIChpZGVudGlmaWVycy5yZXByZXNlbnRhdGlvbklkKSB7XG4gICAgICByZXNvbHZlZFRlbXBsYXRlID0gcmVzb2x2ZWRUZW1wbGF0ZS5yZXBsYWNlKFxuICAgICAgICAgICckUmVwcmVzZW50YXRpb25JRCQnLCBTdHJpbmcoaWRlbnRpZmllcnMucmVwcmVzZW50YXRpb25JZCkpO1xuICAgIH1cblxuICAgIGlmIChpZGVudGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJlc29sdmVkVGVtcGxhdGUgPSByZXNvbHZlZFRlbXBsYXRlLnJlcGxhY2UoXG4gICAgICAgICAgJyROdW1iZXIkJywgU3RyaW5nKGlkZW50aWZpZXJzLm51bWJlcikpO1xuICAgIH1cblxuICAgIGlmIChpZGVudGlmaWVycy5zdWJOdW1iZXIpIHtcbiAgICAgIHJlc29sdmVkVGVtcGxhdGUgPSByZXNvbHZlZFRlbXBsYXRlLnJlcGxhY2UoXG4gICAgICAgICAgJyRTdWJOdW1iZXIkJywgU3RyaW5nKGlkZW50aWZpZXJzLm51bWJlcikpO1xuICAgIH1cblxuICAgIGlmIChpZGVudGlmaWVycy5iYW5kd2lkdGgpIHtcbiAgICAgIHJlc29sdmVkVGVtcGxhdGUgPSByZXNvbHZlZFRlbXBsYXRlLnJlcGxhY2UoXG4gICAgICAgICAgJyRCYW5kd2lkdGgkJywgU3RyaW5nKGlkZW50aWZpZXJzLmJhbmR3aWR0aCkpO1xuICAgIH1cblxuICAgIGlmIChpZGVudGlmaWVycy50aW1lKSB7XG4gICAgICByZXNvbHZlZFRlbXBsYXRlID0gcmVzb2x2ZWRUZW1wbGF0ZS5yZXBsYWNlKFxuICAgICAgICAgICckVGltZSQnLCBTdHJpbmcoaWRlbnRpZmllcnMudGltZSkpO1xuICAgIH1cblxuICAgIGlmIChiYXNlVXJsPy5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgIHJlc29sdmVkVGVtcGxhdGUgPSBuZXcgd2luZG93LlVSTChyZXNvbHZlZFRlbXBsYXRlLCBiYXNlVXJsKS5ocmVmO1xuICAgIH1cblxuICAgIHJldHVybiByZXNvbHZlZFRlbXBsYXRlO1xuICB9XG5cblxuICBzdGF0aWMgZ2V0VHlwZUZyb21NaW1lVHlwZSAobWltZVR5cGU6IHN0cmluZykgOiBzdHJpbmcge1xuICAgIGlmICghbWltZVR5cGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gbWltZVR5cGUuc3BsaXQoJy8nKVswXSB8fCAnJztcbiAgfVxuXG5cbiAgc3RhdGljIGdldEZ1bGxNaW1lVHlwZSAoc3RyZWFtOiBJUmVwcmVzZW50YXRpb24pIDogc3RyaW5nIHtcbiAgICBsZXQgZnVsbE1pbWVUeXBlID0gc3RyZWFtLm1pbWVUeXBlO1xuICAgIGlmIChzdHJlYW0uY29kZWNzKSB7XG4gICAgICBmdWxsTWltZVR5cGUgKz0gJzsgY29kZWNzPVwiJyArIHN0cmVhbS5jb2RlY3MgKyAnXCInO1xuICAgIH1cbiAgICByZXR1cm4gZnVsbE1pbWVUeXBlO1xuICB9XG59XG4iLCJcbmV4cG9ydCBjbGFzcyBBc3luY1Rhc2s8VD4ge1xuICBwdWJsaWMgcHJvbWlzZTogUHJvbWlzZTxUPjtcbiAgcHVibGljIGRvbmU6ICh2YWx1ZTogVCB8IFByb21pc2VMaWtlPFQ+KSA9PiB2b2lkID0gKCkgPT4ge307XG4gIHB1YmxpYyBmYWlsOiAoZXJyb3I/OiBhbnkpID0+IHZvaWQgPSAoKSA9PiB7fTtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5kb25lID0gKHZhbHVlKSA9PiByZXNvbHZlKHZhbHVlKTtcbiAgICAgIHRoaXMuZmFpbCA9IChlcnJvcikgPT4gcmVqZWN0KGVycm9yKTtcbiAgICB9KVxuICB9XG5cbiAgdGltZU91dCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwiXG5leHBvcnQgdHlwZSBCdWZmZXJlZFJhbmdlID0ge1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBjbGFzcyBUaW1lUmFuZ2VzVXRpbHMge1xuXG4gIHN0YXRpYyBnZXRCdWZmZXJlZEluZm8gKGI6IFRpbWVSYW5nZXMpIDogQnVmZmVyZWRSYW5nZVtdIHtcbiAgICBpZiAoIWIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXQucHVzaCh7c3RhcnQ6IGIuc3RhcnQoaSksIGVuZDogYi5lbmQoaSl9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG5cbiAgc3RhdGljIGJ1ZmZlcmVkQWhlYWRPZiAoYjogVGltZVJhbmdlcywgdGltZTogbnVtYmVyKSA6IG51bWJlciB7XG4gICAgaWYgKCFiIHx8ICFiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFdvcmthcm91bmQgU2FmYXJpIGJ1ZzogaHR0cHM6Ly9iaXQubHkvMnRyeDZPOFxuICAgIGlmIChiLmxlbmd0aCA9PSAxICYmIGIuZW5kKDApIC0gYi5zdGFydCgwKSA8IDFlLTYpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbGN1bGF0ZSB0aGUgYnVmZmVyZWQgYW1vdW50IGJ5IE9OTFkgYWNjb3VudGluZyBmb3IgdGhlIGNvbnRlbnRcbiAgICAvLyBidWZmZXJlZCAoaS5lLiB3ZSBpZ25vcmUgdGhlIHRpbWVzIG9mIHRoZSBnYXBzKS4gIFdlIGFsc28gYnVmZmVyIHRocm91Z2hcbiAgICAvLyBhbGwgZ2Fwcy5cbiAgICAvLyBUaGVyZWZvcmUsIHdlIHN0YXJ0IGF0IHRoZSBlbmQgYW5kIGFkZCB1cCBhbGwgYnVmZmVycyB1bnRpbCB8dGltZXwuXG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgZm9yIChjb25zdCB7c3RhcnQsIGVuZH0gb2YgVGltZVJhbmdlc1V0aWxzLmdldEJ1ZmZlcmVkSW5mbyhiKSkge1xuICAgICAgaWYgKGVuZCA+IHRpbWUpIHtcbiAgICAgICAgcmVzdWx0ICs9IGVuZCAtIE1hdGgubWF4KHN0YXJ0LCB0aW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iLCJpbXBvcnQgeyBQYXJzZXJVdGlscyB9IGZyb20gJy4vZGFzaC9wYXJzZXItdXRpbHMnO1xuaW1wb3J0IHsgSVJlcHJlc2VudGF0aW9uLCBNZWRpYVR5cGUgfSBmcm9tICcuL2Rhc2gvdHlwZXMnO1xuaW1wb3J0IHsgQXN5bmNUYXNrIH0gZnJvbSAnLi91dGlscy9hc3luYy10YXNrJztcbmltcG9ydCB7IFRpbWVSYW5nZXNVdGlscyB9IGZyb20gJy4vdXRpbHMvdGltZS1yYW5nZXMnO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgSU1zZUFkYXB0ZXIge1xuICBvcGVuTWVkaWFTb3VyY2UgKCkgOiBQcm9taXNlPHZvaWQ+O1xuICBjbG9zZU1lZGlhU291cmNlICgpIDogdm9pZDtcbiAgc2V0dXBTb3VyY2VCdWZmZXJzIChzdHJlYW1NYXA6IE1hcDxNZWRpYVR5cGUsIElSZXByZXNlbnRhdGlvbj4pIDogUHJvbWlzZTx2b2lkPjtcbiAgYXBwZW5kQnVmZmVyIChtZWRpYVR5cGU6IE1lZGlhVHlwZSwgZGF0YTogQXJyYXlCdWZmZXIpIDogUHJvbWlzZTx2b2lkPjtcbiAgc2V0Q3VycmVudFRpbWUgKHRpbWU6IG51bWJlcikgOiB2b2lkO1xuICBzZXREdXJhdGlvbiAoZHVyYXRpb246IG51bWJlcikgOiB2b2lkO1xuICBnZXRCdWZmZXJlZEFoZWFkT2YgKG1lZGlhVHlwZTogTWVkaWFUeXBlLCB0aW1lOiBudW1iZXIpIDogbnVtYmVyO1xuICBnZXRCdWZmZXJFbmQgKG1lZGlhVHlwZTogTWVkaWFUeXBlKSA6IG51bWJlciB8IG51bGw7XG4gIHN0b3AgKCkgOiB2b2lkO1xufVxuXG5cbnR5cGUgQnVmZmVyQXBwZW5kQ29udGV4dCA9IHtcbiAgbWVkaWFUeXBlOiBNZWRpYVR5cGU7XG4gIGRhdGE6IEFycmF5QnVmZmVyO1xuICBvcGVyYXRpb246IEFzeW5jVGFzazx2b2lkPjtcbiAgc2NoZWR1bGVkOiBib29sZWFuO1xufVxuXG50eXBlIEV2ZW50Q2FsbGJhY2sgPSAoZTogRXZlbnQpID0+IGFueTtcblxuLyoqXG4gKiBUaGUgYSB3cmFwcGVyIGNsYXNzIGFyb3VuZCB0aGUgTVNFIEFQSXMgdG8gcHJvdmlkZSBhIFwiYmV0dGVyXCIgaGFuZGxlIHRoZXJlb2YuXG4gKi9cbmV4cG9ydCBjbGFzcyBNc2VBZGFwdGVyIGltcGxlbWVudHMgSU1zZUFkYXB0ZXIge1xuICBwcml2YXRlIHZpZGVvXzogSFRNTE1lZGlhRWxlbWVudDtcbiAgcHJpdmF0ZSBtZWRpYVNvdXJjZV86IE1lZGlhU291cmNlIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgb2JqZWN0VXJsXzogc3RyaW5nID0gJyc7XG4gIHByaXZhdGUgc291cmNlQnVmZmVyc186IE1hcDxNZWRpYVR5cGUsIFNvdXJjZUJ1ZmZlcj4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgbWVkaWFTb3VyY2VPcGVuVGFza186IEFzeW5jVGFzazx2b2lkPjtcbiAgcHJpdmF0ZSBhcHBlbmRRXzogTWFwPE1lZGlhVHlwZSwgQnVmZmVyQXBwZW5kQ29udGV4dFtdPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBvblVwZGF0ZUVuZFZpZGVvXzogRXZlbnRDYWxsYmFjaztcbiAgcHJpdmF0ZSBvbkVycm9yVmlkZW9fOiBFdmVudENhbGxiYWNrO1xuICBwcml2YXRlIG9uVXBkYXRlRW5kQXVkaW9fOiBFdmVudENhbGxiYWNrO1xuICBwcml2YXRlIG9uRXJyb3JBdWRpb186IEV2ZW50Q2FsbGJhY2s7XG5cblxuICBjb25zdHJ1Y3RvciAodmlkZW86IEhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgICB0aGlzLnZpZGVvXyA9IHZpZGVvO1xuICAgIHRoaXMubWVkaWFTb3VyY2VPcGVuVGFza18gPSBuZXcgQXN5bmNUYXNrPHZvaWQ+KCk7XG4gICAgdGhpcy5vblVwZGF0ZUVuZFZpZGVvXyA9IChfKSA9PiB7XG4gICAgICB0aGlzLm9uVXBkYXRlRW5kXyhNZWRpYVR5cGUuVklERU8pO1xuICAgIH07XG4gICAgdGhpcy5vbkVycm9yVmlkZW9fID0gKGUpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCcobXNlKSB2aWRlbyBzb3VyY2UgYnVmZmVyIGVycm9yJywgZSk7XG4gICAgfVxuICAgIHRoaXMub25VcGRhdGVFbmRBdWRpb18gPSAoXykgPT4ge1xuICAgICAgdGhpcy5vblVwZGF0ZUVuZF8oTWVkaWFUeXBlLkFVRElPKTtcbiAgICB9O1xuICAgIHRoaXMub25FcnJvckF1ZGlvXyA9IChlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnKG1zZSkgYXVkaW8gc291cmNlIGJ1ZmZlciBlcnJvcicsIGUpO1xuICAgIH1cbiAgfVxuXG5cbiAgb3Blbk1lZGlhU291cmNlICgpIDogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgb25Tb3VyY2VPcGVuID0gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ21lZGlhIHNvdXJjZSBpcyBvcGVuLi4uJyk7XG5cbiAgICAgIHRoaXMubWVkaWFTb3VyY2VfPy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICdzb3VyY2VvcGVuJywgb25Tb3VyY2VPcGVuKTtcblxuICAgICAgdGhpcy5tZWRpYVNvdXJjZU9wZW5UYXNrXy5kb25lKCk7XG4gICAgfTtcblxuICAgIHRoaXMubWVkaWFTb3VyY2VfID0gbmV3IE1lZGlhU291cmNlKCk7XG4gICAgdGhpcy5tZWRpYVNvdXJjZV8uYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIG9uU291cmNlT3Blbik7XG4gICAgdGhpcy5vYmplY3RVcmxfID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5tZWRpYVNvdXJjZV8pO1xuICAgIHRoaXMudmlkZW9fLnNyYyA9IHRoaXMub2JqZWN0VXJsXztcblxuICAgIHJldHVybiB0aGlzLm1lZGlhU291cmNlT3BlblRhc2tfLnByb21pc2U7XG4gIH1cblxuXG4gIHN0b3AgKCkgOiB2b2lkIHtcbiAgICAvLyBUT0RPIC0gQWJvcnQgb25nb2luZyBvcGVyYXRpb25zIG9uIHNvdXJjZSBidWZmZXJzIGZpcnN0IVxuICAgIHRoaXMuc291cmNlQnVmZmVyc18uZm9yRWFjaCgoc291cmNlQnVmZmVyLCBtZWRpYVR5cGUpID0+IHtcbiAgICAgIGlmIChtZWRpYVR5cGUgPT09IE1lZGlhVHlwZS5WSURFTykge1xuICAgICAgICBzb3VyY2VCdWZmZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uRXJyb3JWaWRlb18pO1xuICAgICAgICBzb3VyY2VCdWZmZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vblVwZGF0ZUVuZFZpZGVvXyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuXG4gIGNsb3NlTWVkaWFTb3VyY2UgKCkgOiB2b2lkIHtcbiAgICB0aGlzLnN0b3AoKTtcblxuICAgIGlmICh0aGlzLm9iamVjdFVybF8pIHtcbiAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMub2JqZWN0VXJsXyk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VCdWZmZXJzXy5mb3JFYWNoKHNvdXJjZUJ1ZmZlciA9PiB7XG4gICAgICB0aGlzLm1lZGlhU291cmNlXz8ucmVtb3ZlU291cmNlQnVmZmVyKHNvdXJjZUJ1ZmZlcik7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1lZGlhU291cmNlXyA9IG51bGw7XG4gIH07XG5cblxuICBhc3luYyBzZXR1cFNvdXJjZUJ1ZmZlcnMgKFxuICAgICAgc3RyZWFtTWFwOiBNYXA8TWVkaWFUeXBlLCBJUmVwcmVzZW50YXRpb24+KSA6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMubWVkaWFTb3VyY2VPcGVuVGFza187XG5cbiAgICBpZiAoIXRoaXMubWVkaWFTb3VyY2VfKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIE1lZGlhU291cmNlIScpO1xuICAgIH1cblxuICAgIGNvbnN0IHZpZGVvU3RyZWFtID0gc3RyZWFtTWFwLmdldChNZWRpYVR5cGUuVklERU8pO1xuICAgIGNvbnN0IGF1ZGlvU3RyZWFtID0gc3RyZWFtTWFwLmdldChNZWRpYVR5cGUuQVVESU8pO1xuXG4gICAgaWYgKHZpZGVvU3RyZWFtKSB7XG4gICAgICB0aGlzLmFkZFNvdXJjZUJ1ZmZlcl8oTWVkaWFUeXBlLlZJREVPLCB2aWRlb1N0cmVhbSk7XG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvU3RyZWFtKSB7XG4gICAgICB0aGlzLmFkZFNvdXJjZUJ1ZmZlcl8oTWVkaWFUeXBlLkFVRElPLCBhdWRpb1N0cmVhbSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc291cmNlQnVmZmVyc18uc2l6ZSA8IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IHNldHVwIHNvdXJjZSBidWZmZXJzLi4uJyk7XG4gICAgfVxuICB9XG5cblxuICBhcHBlbmRCdWZmZXIgKG1lZGlhVHlwZTogTWVkaWFUeXBlLCBkYXRhOiBBcnJheUJ1ZmZlcikgOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcnNfLmdldChtZWRpYVR5cGUpO1xuXG4gICAgaWYgKHNvdXJjZUJ1ZmZlcikge1xuICAgICAgaWYgKCF0aGlzLmFwcGVuZFFfLmhhcyhtZWRpYVR5cGUpKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kUV8uc2V0KG1lZGlhVHlwZSwgW10pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhcHBlbmRDb250ZXh0OiBCdWZmZXJBcHBlbmRDb250ZXh0ID0ge1xuICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9wZXJhdGlvbjogbmV3IEFzeW5jVGFzazx2b2lkPigpLFxuICAgICAgICBzY2hlZHVsZWQ6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFwcGVuZFFfLmdldChtZWRpYVR5cGUpPy5wdXNoKGFwcGVuZENvbnRleHQpO1xuICAgICAgdGhpcy5ydW5RdWV1ZV8obWVkaWFUeXBlKTtcbiAgICAgIHJldHVybiBhcHBlbmRDb250ZXh0Lm9wZXJhdGlvbi5wcm9taXNlO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICB9XG5cblxuICBzZXRDdXJyZW50VGltZSAodGltZTogbnVtYmVyKSA6IHZvaWQge1xuICAgIGNvbnNvbGUuYXNzZXJ0KHRpbWUgPj0gMCwgJ0N1cnJlbnQgdGltZSBjYW4gbm90IGJlIG5lZ2F0aXZlJyk7XG4gICAgdGhpcy52aWRlb18uY3VycmVudFRpbWUgPSB0aW1lO1xuICB9XG5cblxuICBzZXREdXJhdGlvbiAoZHVyYXRpb246IG51bWJlcikgOiB2b2lkIHtcbiAgICBpZiAodGhpcy5tZWRpYVNvdXJjZV8pIHtcbiAgICAgIHRoaXMubWVkaWFTb3VyY2VfLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgfVxuICB9XG5cblxuICBnZXRCdWZmZXJFbmQgKG1lZGlhVHlwZTogTWVkaWFUeXBlKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgY29uc3Qgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJzXy5nZXQobWVkaWFUeXBlKTtcbiAgICBpZiAoc291cmNlQnVmZmVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByYW5nZXMgPSBzb3VyY2VCdWZmZXIuYnVmZmVyZWQ7XG5cbiAgICAgICAgaWYgKHJhbmdlcyAhPT0gbnVsbCAmJiB0eXBlb2YgcmFuZ2VzICE9PSAndW5kZWZpbmVkJyAmJiByYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlcy5lbmQocmFuZ2VzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvdWxkIG5vdCBnZXQgdGltZSByYW5nZXMgZm9yICcsIG1lZGlhVHlwZSwgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cblxuICBnZXRCdWZmZXJlZEFoZWFkT2YgKG1lZGlhVHlwZTogTWVkaWFUeXBlLCB0aW1lOiBudW1iZXIpIDogbnVtYmVyIHtcbiAgICBsZXQgYnVmZmVyZWRBaGVhZCA9IDA7XG4gICAgY29uc3Qgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJzXy5nZXQobWVkaWFUeXBlKTtcbiAgICBpZiAoc291cmNlQnVmZmVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByYW5nZXMgPSBzb3VyY2VCdWZmZXIuYnVmZmVyZWQ7XG4gICAgICAgIGJ1ZmZlcmVkQWhlYWQgPSBUaW1lUmFuZ2VzVXRpbHMuYnVmZmVyZWRBaGVhZE9mKHJhbmdlcywgdGltZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvdWxkIG5vdCBnZXQgdGltZSByYW5nZXMgZm9yICcsIG1lZGlhVHlwZSwgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJlZEFoZWFkO1xuICB9XG5cblxuICBwcml2YXRlIG9uVXBkYXRlRW5kXyAobWVkaWFUeXBlOiBNZWRpYVR5cGUpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuYXBwZW5kUV8uZ2V0KG1lZGlhVHlwZSk7XG4gICAgLy8gUG9wIGZyb20gcXVldWVcbiAgICBjb25zdCBjb250ZXh0ID0gcXVldWU/LnNoaWZ0KClcblxuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICBjb25zb2xlLmFzc2VydChcbiAgICAgICAgICBjb250ZXh0LnNjaGVkdWxlZCxcbiAgICAgICAgICAnQnVnOiAobXNlKSBmaXJzdCBpdGVtIGluIHRoZSBxdWV1ZSBzaG91bGQgaGF2ZSBiZWVuIHNjaGVkdWxlZCEnKTtcblxuICAgICAgLy8gUmVzb2x2ZSBvcGVyYXRpb24gcHJvbWlzZVxuICAgICAgY29udGV4dC5vcGVyYXRpb24uZG9uZSgpO1xuICAgICAgLy8gUnVuIHF1ZXVlXG4gICAgICB0aGlzLnJ1blF1ZXVlXyhtZWRpYVR5cGUpO1xuICAgIH1cbiAgfVxuXG5cbiAgcHJpdmF0ZSBydW5RdWV1ZV8gKG1lZGlhVHlwZTogTWVkaWFUeXBlKSA6IHZvaWQge1xuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyc18uZ2V0KG1lZGlhVHlwZSk7XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLmFwcGVuZFFfLmdldChtZWRpYVR5cGUpO1xuXG4gICAgY29uc29sZS5hc3NlcnQoXG4gICAgICAgICEhcXVldWUgfHwgISFzb3VyY2VCdWZmZXIsICdCdWc6IChtc2UpIGludmFsaWQgY2FsbCB0byBydW5RdWV1ZV8oKScpO1xuXG4gICAgaWYgKCFxdWV1ZSB8fCAhc291cmNlQnVmZmVyKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VjY2Vzc2Z1bCBhdHRlbXB0IHRvIHVwZGF0ZSBidWZmZXInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIHRvXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZUJ1ZmZlci51cGRhdGluZykge1xuICAgICAgLy8gV2FpdCBmb3IgdXBkYXRlZW5kXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRklGT1xuICAgIGNvbnN0IG5leHQgPSBxdWV1ZVswXTtcblxuICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICAhbmV4dC5zY2hlZHVsZWQsICdCdWc6IChtc2UpIGZvdW5kIHNjaGVkdWxlZCBpdGVtIGluIHJ1biBxdWV1ZSEnKTtcblxuICAgIG5leHQuc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBzb3VyY2VCdWZmZXIuYXBwZW5kQnVmZmVyKG5ldyBVaW50OEFycmF5KG5leHQuZGF0YSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNvdXJjZSBidWZmZXIgZm9yIHxtZWRpYVR5cGV8IGFuZCBhZGQgaXQgdG8gdGhlIG1lZGlhIHNvdXJjZVxuICAgKiBAcGFyYW0gbWVkaWFUeXBlXG4gICAqIEBwYXJhbSBzdHJlYW1cbiAgICovXG4gIHByaXZhdGUgYWRkU291cmNlQnVmZmVyXyAoXG4gICAgICBtZWRpYVR5cGU6IE1lZGlhVHlwZSwgc3RyZWFtOiBJUmVwcmVzZW50YXRpb24pIDogdm9pZCB7XG4gICAgaWYgKHRoaXMubWVkaWFTb3VyY2VfKSB7XG4gICAgICBjb25zdCBmdWxsTWltZVR5cGUgPSBQYXJzZXJVdGlscy5nZXRGdWxsTWltZVR5cGUoc3RyZWFtKTtcbiAgICAgIGNvbnN0IHN1cHBvcnRlZEJ5UGxhdGZvcm0gPSBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoZnVsbE1pbWVUeXBlKVxuXG4gICAgICBjb25zb2xlLmFzc2VydChcbiAgICAgICAgICBtZWRpYVR5cGUgPT09IE1lZGlhVHlwZS5WSURFTyB8fCBtZWRpYVR5cGUgPT09IE1lZGlhVHlwZS5BVURJTyxcbiAgICAgICAgICAnSW52YWxpZCBtZWRpYSB0eXBlIScpO1xuXG4gICAgICBjb25zb2xlLmFzc2VydChcbiAgICAgICAgc3VwcG9ydGVkQnlQbGF0Zm9ybSxcbiAgICAgICAgJ1R5cGUgbXVzdCBzdXBwb3J0ZWQgYnkgcGxhdGZvcm0hJywgZnVsbE1pbWVUeXBlKTtcblxuICAgICAgaWYgKCFzdXBwb3J0ZWRCeVBsYXRmb3JtKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBTa2lwcGluZyAke21lZGlhVHlwZX0gc3RyZWFtIGJlY2F1c2Ugbm90IHN1cHBvcnRlZCBieSBwbGF0Zm9ybS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzb3VyY2VCdWZmZXIgPSB0aGlzLm1lZGlhU291cmNlXy5hZGRTb3VyY2VCdWZmZXIoZnVsbE1pbWVUeXBlKTtcblxuICAgICAgaWYgKG1lZGlhVHlwZSA9PT0gTWVkaWFUeXBlLlZJREVPKSB7XG4gICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uVXBkYXRlRW5kVmlkZW9fKTtcbiAgICAgICAgc291cmNlQnVmZmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbkVycm9yVmlkZW9fKTtcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzXy5zZXQoTWVkaWFUeXBlLlZJREVPLCBzb3VyY2VCdWZmZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFUeXBlID09PSBNZWRpYVR5cGUuQVVESU8pIHtcbiAgICAgICAgc291cmNlQnVmZmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25VcGRhdGVFbmRBdWRpb18pO1xuICAgICAgICBzb3VyY2VCdWZmZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uRXJyb3JBdWRpb18pO1xuICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnNfLnNldChNZWRpYVR5cGUuQVVESU8sIHNvdXJjZUJ1ZmZlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJcbmltcG9ydCB7IElUaW1lciB9IGZyb20gJy4vdHlwZXMnO1xuXG5cbmV4cG9ydCBjbGFzcyBUaW1lciBpbXBsZW1lbnRzIElUaW1lciB7XG4gIHByaXZhdGUgdGltZXJJZF86IG51bWJlciB8IG51bGw7XG4gIHByaXZhdGUgY2xlYXJNZXRob2RfOiBGdW5jdGlvbiB8IG51bGw7XG4gIHByaXZhdGUgb25UaWNrXzogRnVuY3Rpb247XG5cbiAgY29uc3RydWN0b3IgKGhhbmRsZXI6IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy50aW1lcklkXyA9IG51bGw7XG4gICAgdGhpcy5jbGVhck1ldGhvZF8gPSBudWxsO1xuICAgIHRoaXMub25UaWNrXyA9IGhhbmRsZXI7XG4gIH1cblxuICB0aWNrQWZ0ZXIgKHNlY29uZHM6IG51bWJlcikgOiBJVGltZXIge1xuICAgIHJldHVybiB0aGlzLnNldFRpbWVyXyhzZWNvbmRzLCBmYWxzZSk7XG4gIH1cblxuICB0aWNrRXZlcnkgKHNlY29uZHM6IG51bWJlcikgOiBJVGltZXIge1xuICAgIHJldHVybiB0aGlzLnNldFRpbWVyXyhzZWNvbmRzLCB0cnVlKTtcbiAgfVxuXG4gIGNsZWFyICgpIDogdm9pZCB7XG4gICAgaWYgKHRoaXMudGltZXJJZF8gJiYgdGhpcy5jbGVhck1ldGhvZF8pIHtcbiAgICAgIHRoaXMuY2xlYXJNZXRob2RfKHRoaXMudGltZXJJZF8pO1xuICAgICAgdGhpcy50aW1lcklkXyA9IG51bGw7XG4gICAgICB0aGlzLmNsZWFyTWV0aG9kXyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRUaW1lcl8gKHNlY29uZHM6IG51bWJlciwgaXNQZXJpb2RpYzogYm9vbGVhbikgOiBJVGltZXIge1xuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIGNvbnN0IGNiID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMudGltZXJJZF8pIHtcbiAgICAgICAgdGhpcy5vblRpY2tfKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUGVyaW9kaWMpIHtcbiAgICAgIHRoaXMudGltZXJJZF8gPSB3aW5kb3cuc2V0SW50ZXJ2YWwoY2IsIHNlY29uZHMgKiAxMDAwKTtcbiAgICAgIHRoaXMuY2xlYXJNZXRob2RfID0gY2xlYXJJbnRlcnZhbC5iaW5kKHdpbmRvdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGltZXJJZF8gPSB3aW5kb3cuc2V0VGltZW91dChjYiwgc2Vjb25kcyAqIDEwMDApO1xuICAgICAgdGhpcy5jbGVhck1ldGhvZF8gPSBjbGVhclRpbWVvdXQuYmluZCh3aW5kb3cpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBJSHR0cFJlcXVlc3QsXG4gIElIdHRwUmVzcG9uc2UsXG4gIEh0dHBSZXNwb25zZVR5cGUsXG4gIEh0dHBSZXNwb25zZURhdGEsXG4gIEh0dHBSZXF1ZXN0Qm9keSxcbiAgSHR0cFJlcXVlc3RNZXRob2Rcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBIdHRwUmVxdWVzdCBpbXBsZW1lbnRzIElIdHRwUmVxdWVzdCB7XG4gIHByaXZhdGUgdXJsXzogc3RyaW5nO1xuICBwcml2YXRlIG1ldGhvZF86IEh0dHBSZXF1ZXN0TWV0aG9kID0gJ0dFVCc7XG4gIHByaXZhdGUgaGVhZGVyc186IE1hcDxzdHJpbmcsIHN0cmluZz4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgYm9keV86IEh0dHBSZXF1ZXN0Qm9keSA9IG51bGw7XG4gIHByaXZhdGUgcmVzcG9uc2VUeXBlXzogSHR0cFJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgY29uc3RydWN0b3IgKHVybDogc3RyaW5nKSB7XG4gICAgdGhpcy51cmxfID0gdXJsO1xuICB9XG5cbiAgZ2V0IHVybCAoKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudXJsXztcbiAgfVxuXG4gIHNldCB1cmwgKG5ld1VybDogc3RyaW5nKSB7XG4gICAgdGhpcy51cmxfID0gbmV3VXJsO1xuICB9XG5cbiAgZ2V0IG1ldGhvZCAoKSA6IEh0dHBSZXF1ZXN0TWV0aG9kIHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RfO1xuICB9XG5cbiAgc2V0IG1ldGhvZCAobmV3TWV0aG9kOiBIdHRwUmVxdWVzdE1ldGhvZCkge1xuICAgIHRoaXMubWV0aG9kXyA9IG5ld01ldGhvZDtcbiAgfVxuXG4gIGdldCByZXNwb25zZVR5cGUgKCkgOiBIdHRwUmVzcG9uc2VUeXBlIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZVR5cGVfO1xuICB9XG5cbiAgc2V0IHJlc3BvbnNlVHlwZSAobmV3UmVzcG9uc2VUeXBlOiBIdHRwUmVzcG9uc2VUeXBlKSB7XG4gICAgdGhpcy5yZXNwb25zZVR5cGVfID0gbmV3UmVzcG9uc2VUeXBlO1xuICB9XG5cbiAgZ2V0IGJvZHkgKCkgOiBIdHRwUmVxdWVzdEJvZHkge1xuICAgIHJldHVybiB0aGlzLmJvZHlfXG4gIH1cblxuICBzZXQgYm9keSAoYm9keTogSHR0cFJlcXVlc3RCb2R5KSB7XG4gICAgdGhpcy5ib2R5XyA9IGJvZHk7XG4gIH1cblxuICBnZXQgaGVhZGVycyAoKSA6IE1hcDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmhlYWRlcnNfO1xuICB9XG5cbiAgc2V0SGVhZGVyIChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuaGVhZGVyc18uc2V0KGtleSwgdmFsdWUpXG4gIH1cbn1cblxuXG5leHBvcnQgY2xhc3MgSHR0cFJlc3BvbnNlIGltcGxlbWVudHMgSUh0dHBSZXNwb25zZSB7XG4gIHByaXZhdGUgcmVxdWVzdF86IElIdHRwUmVxdWVzdDtcbiAgcHJpdmF0ZSBzdGF0dXNfOiBudW1iZXI7XG4gIHByaXZhdGUgaGVhZGVyc186IHN0cmluZztcbiAgcHJpdmF0ZSBkYXRhXzogSHR0cFJlc3BvbnNlRGF0YTtcbiAgcHJpdmF0ZSBva186IGJvb2xlYW47XG4gIHByaXZhdGUgbWVzc2FnZV86IHN0cmluZyA9ICcnO1xuXG4gIGNvbnN0cnVjdG9yIChcbiAgICAgIHJlcXVlc3Q6IElIdHRwUmVxdWVzdCwgc3RhdHVzOiBudW1iZXIsIGhlYWRlcnM6IHN0cmluZyxcbiAgICAgIGRhdGE6IEh0dHBSZXNwb25zZURhdGEsIG9rOiBib29sZWFuLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnJlcXVlc3RfID0gcmVxdWVzdDtcbiAgICB0aGlzLnN0YXR1c18gPSBzdGF0dXM7XG4gICAgdGhpcy5oZWFkZXJzXyA9IGhlYWRlcnM7XG4gICAgdGhpcy5kYXRhXyA9IGRhdGE7XG4gICAgdGhpcy5va18gPSBvaztcbiAgICB0aGlzLm1lc3NhZ2VfID0gbWVzc2FnZTtcbiAgfVxuXG4gIGdldCByZXF1ZXN0ICgpIDogSUh0dHBSZXF1ZXN0IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0XztcbiAgfVxuXG4gIGdldCBzdGF0dXMgKCkgOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnN0YXR1c187XG4gIH1cblxuICBnZXQgaGVhZGVycyAoKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZGVyc187XG4gIH1cblxuICBnZXQgZGF0YSAoKSA6IEh0dHBSZXNwb25zZURhdGEge1xuICAgIHJldHVybiB0aGlzLmRhdGFfO1xuICB9XG5cbiAgZ2V0IG9rICgpIDogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMub2tfO1xuICB9XG5cbiAgZ2V0IG1lc3NhZ2UgKCkgOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VfO1xuICB9XG5cbn1cblxuXG5leHBvcnQgY2xhc3MgTmV0d29ya0hhbmRsZSB7XG4gIHN0YXRpYyBmZXRjaCAocmVxdWVzdDogSUh0dHBSZXF1ZXN0KSA6IFByb21pc2U8SUh0dHBSZXNwb25zZT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWFrZVJlc3BvbnNlID0gKGlzT2s6IGJvb2xlYW4pIDogSUh0dHBSZXNwb25zZSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgSHR0cFJlc3BvbnNlKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCksXG4gICAgICAgICAgeGhyLnJlc3BvbnNlLFxuICAgICAgICAgIGlzT2ssXG4gICAgICAgICAgeGhyLnN0YXR1c1RleHRcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmxvYWQgPSAoZXYpID0+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApKTtcblxuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSB4aHIub25hYm9ydCA9IChldikgPT4ge1xuICAgICAgICByZWplY3QobWFrZVJlc3BvbnNlKGZhbHNlKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIuc2VuZChyZXF1ZXN0LmJvZHkpO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBJSHR0cFJlc3BvbnNlLCBJVGltZXIgfSBmcm9tIFwiLi91dGlscy90eXBlc1wiO1xuaW1wb3J0IHsgSU1zZUFkYXB0ZXIgfSBmcm9tIFwiLi9tc2UtYWRhcHRlclwiO1xuaW1wb3J0IHtcbiAgSVJlcHJlc2VudGF0aW9uLFxuICBJU2VnbWVudCxcbiAgTWVkaWFUeXBlLFxuICBJUHJlc2VudGF0aW9uXG59IGZyb20gXCIuL2Rhc2gvdHlwZXNcIjtcbmltcG9ydCB7IFRpbWVyIH0gZnJvbSBcIi4vdXRpbHMvdGltZXJcIjtcbmltcG9ydCB7IEh0dHBSZXF1ZXN0LCBOZXR3b3JrSGFuZGxlIH0gZnJvbSBcIi4vdXRpbHMvbmV0d29ya1wiO1xuXG5cbmludGVyZmFjZSBNZWRpYVN0YXRlIHtcbiAgdHlwZTogTWVkaWFUeXBlO1xuICBzdHJlYW06IElSZXByZXNlbnRhdGlvbjtcbiAgbmVlZEluaXQ6IGJvb2xlYW47XG4gIGxhc3RTZWdtZW50OiBJU2VnbWVudCB8IG51bGw7XG4gIHVwZGF0aW5nOiBib29sZWFuO1xuICBzY2hlZHVsZVRpbWVyOiBJVGltZXIgfCBudWxsO1xufVxuXG4vKipcbiAqIFRoZSBTdHJlYW1lclxuICpcbiAqIFRoaXMgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIHN0cmVhbWluZyB0aGUgbWVkaWEgY29udGVudCBieSBsZXZlcmFnaW5nXG4gKiB0aGUgTVNFIEFQSXMgKHZpYSB0aGUgTVNFIEFkYXB0ZXIpLlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtZXIge1xuICBwcml2YXRlIG1zZV86IElNc2VBZGFwdGVyO1xuICBwcml2YXRlIHByZXNlbnRhdGlvbl86IElQcmVzZW50YXRpb247XG4gIHByaXZhdGUgbWVkaWFTdGF0ZXNfOiBNYXA8TWVkaWFUeXBlLCBNZWRpYVN0YXRlPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBzdGFydFRpbWVfOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBzdG9wcGVkXzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIHJlYWRvbmx5IHNjaGVkdWxlSW50ZXJ2YWw6IG51bWJlciA9IDAuMjU7XG5cblxuICBjb25zdHJ1Y3RvciAobXNlQWRhcHRlcjogSU1zZUFkYXB0ZXIsIHByZXNlbnRhdGlvbjogSVByZXNlbnRhdGlvbikge1xuICAgIHRoaXMubXNlXyA9IG1zZUFkYXB0ZXI7XG4gICAgdGhpcy5wcmVzZW50YXRpb25fID0gcHJlc2VudGF0aW9uO1xuICB9XG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgc2V0cyB1cCB0aGUgc3RyZWFtZXIuIEl0IG5lZWRzIHRvIGJlIGNhbGxlZCBmaXJzdCFcbiAgICogVXBvbiBjYWxsLCBpdCB3aWxsIG9wZW4gdGhlIG1lZGlhIHNvdXJjZSBhbmQgc2V0dXAgc291cmNlIGJ1ZmZlcnMgZm9yXG4gICAqIHN0cmVhbXMgaW4gfHN0cmVhbU1hcHwuIEZ1dGhlcm1vcmUgaXQgd2lsbCBjcmVhdGUgYW4gaW50ZXJuYWwgbWVkaWEgc3RhdGVcbiAgICogZm9yIGVhY2ggc3RyZWFtIGluIHxzdHJlYW1NYXB8OyB0aGUgbWVkaWEgc3RhdGUga2VlcHMgcmVjb3JkIG9mIHRoZVxuICAgKiBzdHJlYW0ncyBjb250ZXh0IHRoZSBzdHJlYW1lciBuZWVkcyB0byBvcGVyYXRlIGNvcnJlY3RseS5cbiAgICpcbiAgICogQHBhcmFtIHN0cmVhbU1hcCBBIG1hcCBjb250YWluaW5nIGluaXRpYWwgc3RyZWFtc1xuICAgKiBAcmV0dXJucyBQcm9taXNlXG4gICAqL1xuICBhc3luYyBzZXR1cCAoc3RyZWFtTWFwOiBNYXA8TWVkaWFUeXBlLCBJUmVwcmVzZW50YXRpb24+KSA6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMubXNlXy5vcGVuTWVkaWFTb3VyY2UoKTtcbiAgICBhd2FpdCB0aGlzLm1zZV8uc2V0dXBTb3VyY2VCdWZmZXJzKHN0cmVhbU1hcCk7XG5cbiAgICAvLyBDcmVhdGUgbWVkaWEgc3RhdGVzXG4gICAgc3RyZWFtTWFwLmZvckVhY2goKHN0cmVhbSwgbWVkaWF0VHlwZSkgPT4ge1xuICAgICAgaWYgKG1lZGlhdFR5cGUgPT09IE1lZGlhVHlwZS5WSURFTykge1xuICAgICAgICBpZiAoIXRoaXMubWVkaWFTdGF0ZXNfLmhhcyhtZWRpYXRUeXBlKSkge1xuICAgICAgICAgIHRoaXMubWVkaWFTdGF0ZXNfLnNldChcbiAgICAgICAgICAgICAgbWVkaWF0VHlwZSwgdGhpcy5jcmVhdGVNZWRpYVN0YXRlXyhtZWRpYXRUeXBlLCBzdHJlYW0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWF0VHlwZSA9PT0gTWVkaWFUeXBlLkFVRElPKSB7XG4gICAgICAgIGlmICghdGhpcy5tZWRpYVN0YXRlc18uaGFzKG1lZGlhdFR5cGUpKSB7XG4gICAgICAgICAgdGhpcy5tZWRpYVN0YXRlc18uc2V0KFxuICAgICAgICAgICAgICBtZWRpYXRUeXBlLCB0aGlzLmNyZWF0ZU1lZGlhU3RhdGVfKG1lZGlhdFR5cGUsIHN0cmVhbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUaGlzIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsIGlzIHdlIGNvdWxkIHNldHVwIGFsbCBzdHJlYW1zLlxuICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICBzdHJlYW1NYXAuc2l6ZSA9PT0gdGhpcy5tZWRpYVN0YXRlc18uc2l6ZSxcbiAgICAgICAgJ1Nob3VsZCBoYXZlIG1lZGlhIHN0YXRlcyBmb3IgYWxsIHR5cGVzJyk7XG5cbiAgICAvLyBTZXQgZHVyYXRpb25cbiAgICBjb25zdCBzdHJlYW0gPVxuICAgICAgICBzdHJlYW1NYXAuZ2V0KE1lZGlhVHlwZS5WSURFTykgfHwgc3RyZWFtTWFwLmdldChNZWRpYVR5cGUuQVVESU8pO1xuXG4gICAgLy8gVE9ETyAtIEFkZCBnZXREdXJhdGlvbigpIHRvIElQcmVzZW50YXRpb25cbiAgICBsZXQgZHVyYXRpb24gPSBzdHJlYW0/LnNlZ21lbnRJbmRleC5nZXRFbmRUaW1lKCk7XG5cbiAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBzZXQgc3RyZWFtIGR1cmF0aW9uIScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByZXNlbnRhdGlvbl8uaXNMaXZlKCkpIHtcbiAgICAgIGR1cmF0aW9uID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgdGhpcy5tc2VfLnNldER1cmF0aW9uKGR1cmF0aW9uKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBzdHJlYW1pbmcuIEF0IHRoaXMgcG9pbnQgdGhlIG1lZGlhIHNvdXJjZSBhbmQgc291cmNlIGJ1ZmZlcnNcbiAgICogYXJlIHNldC4gVGhpcyBtZXRob2Qgd2lsbCBzZXQgdGhlIHN0cmVhbSBzdGFydCB0aW1lIGFuZCBhY3RpdmVcbiAgICogdGhlIHNjaGVkdWxlIHRpbWVyIGZvciBlYWNoIG1lZGlhIHN0YXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXJ0ICgpIDogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMubWVkaWFTdGF0ZXNfLnNpemUgPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2FybignU3RyZWFtcyBuZWVkcyB0byBiZSBzZXR1cCBiZWZvcmUgc3RhcnQuIE5vLW9wLi4uJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lXykge1xuICAgICAgY29uc29sZS53YXJuKCdTdHJlYW1pbmcgYWxyZWFkeSBzdGFydGVkLi4uJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5zdG9wcGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRUaW1lXyA9IDA7XG5cbiAgICAvLyBGb3IgbGl2ZSBzdHJlYW0gY2FsY3VsYXRlICd0dW5lLWluJyB0aW1lLlxuICAgIGlmICh0aGlzLnByZXNlbnRhdGlvbl8uaXNMaXZlKCkpIHtcbiAgICAgIGNvbnN0IHByZXNlbnRhdGlvbkRlbGF5ID0gdGhpcy5wcmVzZW50YXRpb25fLmdldERlbGF5KCk7XG4gICAgICB0aGlzLnN0YXJ0VGltZV8gPSBNYXRoLm1heCgwLCB0aGlzLmdldExpdmVFZGdlXygpIC0gcHJlc2VudGF0aW9uRGVsYXkpO1xuICAgIH1cblxuICAgIGNvbnN0IG1lZGlhU3RhdGUgPVxuICAgICAgICB0aGlzLm1lZGlhU3RhdGVzXy5nZXQoTWVkaWFUeXBlLlZJREVPKSB8fFxuICAgICAgICB0aGlzLm1lZGlhU3RhdGVzXy5nZXQoTWVkaWFUeXBlLkFVRElPKTtcblxuICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICBtZWRpYVN0YXRlPy5zdHJlYW0uc2VnbWVudEluZGV4Lmhhc1RpbWUodGhpcy5zdGFydFRpbWVfKSxcbiAgICAgICAgJ0J1ZzogU3RhcnQgdGltZSBpcyBub3Qgd2l0aGluIHRoZSBwcmVzZW50YXRpb24gdGltZWxpbmUnKTtcblxuICAgIGNvbnNvbGUubG9nKCdTdGFydCB0aW1lOicsIHRoaXMuc3RhcnRUaW1lXyk7XG5cbiAgICAvLyBTZXQgdGhlIHN0YXJ0IHRpbWVcbiAgICB0aGlzLm1zZV8uc2V0Q3VycmVudFRpbWUodGhpcy5zdGFydFRpbWVfKTtcblxuICAgIGZvciAoY29uc3QgbWVkaWFTdGF0ZSBvZiB0aGlzLm1lZGlhU3RhdGVzXy52YWx1ZXMoKSkge1xuICAgICAgLy8gU3RhcnQgc3RyZWFtaW5nXG4gICAgICB0aGlzLm9uVGlja18obWVkaWFTdGF0ZSk7XG4gICAgICAvLyBTZXR1cCBzY2hlZHVsZXJcbiAgICAgIG1lZGlhU3RhdGUuc2NoZWR1bGVUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLm9uVGlja18obWVkaWFTdGF0ZSkpO1xuICAgICAgbWVkaWFTdGF0ZS5zY2hlZHVsZVRpbWVyLnRpY2tFdmVyeSh0aGlzLnNjaGVkdWxlSW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3Agc3RyZWFtaW5nLlxuICAgKi9cbiAgc3RvcCAoKSA6IHZvaWQge1xuICAgIHRoaXMuc3RvcHBlZF8gPSB0cnVlO1xuICAgIHRoaXMubXNlXy5jbG9zZU1lZGlhU291cmNlKCk7XG4gICAgZm9yIChjb25zdCBtZWRpYVN0YXRlIG9mIHRoaXMubWVkaWFTdGF0ZXNfLnZhbHVlcygpKSB7XG4gICAgICBtZWRpYVN0YXRlLnNjaGVkdWxlVGltZXI/LmNsZWFyKCk7XG4gICAgICBtZWRpYVN0YXRlLnVwZGF0aW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFRoZSBwcmVzZW50YXRpb24gdGltZSB3ZSBzdGFydGVkIHN0cmVhbWluZyBhdFxuICAgKi9cbiAgZ2V0U3RhcnRUaW1lICgpIDogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRUaW1lXztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RyZWFtIG9mIHR5cGUgfG1lZGlhVHlwZXwgYmVpbmcgY3VycmVudGx5IGJ1ZmZlcmVkXG4gICAqXG4gICAqIEBwYXJhbSBtZWRpYVR5cGUgVGhlIG1lZGlhIHR5cGVcbiAgICogQHJldHVybnMgVGhlIGFjdGl2ZSB8bWVkaWFUeXBlfCBzdHJlYW0gb3IgbnVsbFxuICAgKi9cbiAgZ2V0QWN0aXZlU3RyZWFtIChtZWRpYVR5cGU6IE1lZGlhVHlwZSkgOiBJUmVwcmVzZW50YXRpb24gfCBudWxsIHtcbiAgICBjb25zdCBtZWRpYVN0YXRlID0gdGhpcy5tZWRpYVN0YXRlc18uZ2V0KG1lZGlhVHlwZSk7XG4gICAgaWYgKG1lZGlhU3RhdGUpIHtcbiAgICAgIHJldHVybiBtZWRpYVN0YXRlLnN0cmVhbTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHN0cmVhbSdzIHNjaGVkdWxlciB0aW1lciB0aWNrZWQuIFRoaXMgd2lsbCBjaGVjaywgZm9yIGFuXG4gICAqIGlkbGluZyBzdHJlYW0sIGlmIHRoZXJlIGlzIGEgc2VnbWVudCB0byBkb3dubG9hZCBpbiB3aGljaCBjYXNlXG4gICAqIHxmZXRjaEFuZEFwcGVuZF8oKXwgd2lsbCBiZSBjYWxsZWQgdG8gcGVyZm9ybSB0aGUgYWN0dWFsbHkgZG93bmxvYWRcbiAgICogYW5kIHB1c2ggdGhlIGRhdGEgdG8gdGhlIHNvdXJjZSBidWZmZXIgKHZpYSB0aGUgTVNFIGFkYXB0ZXIpLlxuICAgKlxuICAgKiBAcGFyYW0gbWVkaWFTdGF0ZSBUaGUgbWVkaWEgc3RhdGUgb2YgdGhlIGN1cnJlbnRseSBzY2hlZHVsZWQgc3RyZWFtLlxuICAgKiBAcmV0dXJucyBQcm9taXNlLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBvblRpY2tfIChtZWRpYVN0YXRlOiBNZWRpYVN0YXRlKSA6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLnN0b3BwZWRfKSB7XG4gICAgICAvLyBTdHJlYW1pbmcgaGFzIGJlZW4gc3RvcHBlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtZWRpYVN0YXRlLnVwZGF0aW5nKSB7XG4gICAgICAvLyBNZWRpYSBzdGF0ZSBpcyBzdGlsbCB1cGRhdGluZ1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCBidWZmZXIgbW9yZVxuICAgIGNvbnN0IGJ1ZmZlcmluZ0dvYWwgPSAzMDtcbiAgICBjb25zdCBwbGF5aGVhZFBvc2l0aW9uID0gdGhpcy5wcmVzZW50YXRpb25fLmdldFBvc2l0aW9uKCk7XG4gICAgY29uc3QgYnVmZmVyZWRBaGVhZCA9XG4gICAgICAgIHRoaXMubXNlXy5nZXRCdWZmZXJlZEFoZWFkT2YobWVkaWFTdGF0ZS50eXBlLCBwbGF5aGVhZFBvc2l0aW9uKTtcbiAgICBpZiAoYnVmZmVyZWRBaGVhZCA+IGJ1ZmZlcmluZ0dvYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZWRpYVN0YXRlLnVwZGF0aW5nID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICBsZXQgdGltZU5lZWRlZCA9IHRoaXMuZ2V0VGltZU5lZWRlZF8obWVkaWFTdGF0ZSk7XG4gICAgICBjb25zdCBuZXh0U2VnbWVudCA9IG1lZGlhU3RhdGUuc3RyZWFtLnNlZ21lbnRJbmRleC5maW5kKHRpbWVOZWVkZWQpO1xuXG4gICAgICBpZiAobmV4dFNlZ21lbnQpIHtcbiAgICAgICAgaWYgKG1lZGlhU3RhdGUubmVlZEluaXQpIHtcbiAgICAgICAgICBjb25zdCBpbml0U2VnbWVudCA9IG1lZGlhU3RhdGUuc3RyZWFtLmluaXRpYWxpemF0aW9uO1xuICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hBbmRBcHBlbmRfKG1lZGlhU3RhdGUsIGluaXRTZWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hBbmRBcHBlbmRfKG1lZGlhU3RhdGUsIG5leHRTZWdtZW50KTtcbiAgICAgICAgbWVkaWFTdGF0ZS5sYXN0U2VnbWVudCA9IG5leHRTZWdtZW50O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IG5ldFJlc3BvbmUgPSBlIGFzIElIdHRwUmVzcG9uc2U7XG4gICAgICBpZiAobmV0UmVzcG9uZS5zdGF0dXMgJiYgbmV0UmVzcG9uZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgICAgJ1NlZ21lbnQgcHJlc2VudCBpbiBtYW5pZmVzdCBidXQgc2VydmVyIHJldHVybmVkIEhUVFAgNDA0LicsXG4gICAgICAgICAgJ1dpbGwgcmV0eS4uLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignKHN0cmVhbWluZykgRmV0Y2ggYW5kIGFwcGVuZCBmYWlsZWQuLi4nLCBlKTtcbiAgICAgICAgLy8gdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgbWVkaWFTdGF0ZS51cGRhdGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEZldGNoIHNlZ21lbnQgYW5kIHB1c2ggZGF0YSB0byBidWZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBtZWRpYVN0YXRlIFRoZSBzdHJlYW0ncyBzdGF0ZS9jb250ZXh0LlxuICAgKiBAcGFyYW0gc2VnbWVudCBUaGUgc2VnbWVudCB0byBkb3dubG9hZC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hBbmRBcHBlbmRfIChcbiAgICAgIG1lZGlhU3RhdGU6IE1lZGlhU3RhdGUsIHNlZ21lbnQ6IElTZWdtZW50KSA6IFByb21pc2U8dm9pZD4ge1xuXG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBIdHRwUmVxdWVzdChzZWdtZW50LnVybCk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBOZXR3b3JrSGFuZGxlLmZldGNoKHJlcXVlc3QpO1xuICAgIGF3YWl0IHRoaXMubXNlXy5hcHBlbmRCdWZmZXIobWVkaWFTdGF0ZS50eXBlLCByZXNwb25zZS5kYXRhIGFzIEFycmF5QnVmZmVyKTtcblxuICAgIGlmIChzZWdtZW50LmlzSW5pdCkge1xuICAgICAgbWVkaWFTdGF0ZS5uZWVkSW5pdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCBuZXh0IHRpbWVzdGFtcCB3ZSBuZWVkIHRvIGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIG1lZGlhU3RhdGUgVGhlIHN0cmVhbSBzdGF0ZS9jb250ZXh0LlxuICAgKiBAcmV0dXJucyBUaGUgdGltZSBuZWVkZWQuXG4gICAqL1xuICBwcml2YXRlIGdldFRpbWVOZWVkZWRfIChtZWRpYVN0YXRlOiBNZWRpYVN0YXRlKSA6IG51bWJlciB7XG4gICAgaWYgKG1lZGlhU3RhdGUubGFzdFNlZ21lbnQpIHtcbiAgICAgIHJldHVybiBtZWRpYVN0YXRlLmxhc3RTZWdtZW50LmVuZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJlc2VudGF0aW9uXy5nZXRQb3NpdGlvbigpO1xuICB9XG5cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGxpdmUgZWRnZS5cbiAgICogQHJldHVybnMgVGhlIGxpdmUgZWRnZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRMaXZlRWRnZV8gKCkgOiBudW1iZXIge1xuICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICB0aGlzLnByZXNlbnRhdGlvbl8uaXNMaXZlKCksICdJbnZhbGlkIGNhbGwgdG8gZ2V0TGl2ZUVkZ2VfKCknKTtcbiAgICBjb25zdCBtYXhTZWdtZW50RHVyYXRpb24gPSB0aGlzLnByZXNlbnRhdGlvbl8uZ2V0TWF4U2VnbWVudER1cmF0aW9uKCk7XG4gICAgY29uc3QgcHJlc2VudGF0aW9uU3RhcnRUaW1lID0gdGhpcy5wcmVzZW50YXRpb25fLmdldFN0YXJ0VGltZSgpO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCkgLyAxMDAwO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG5vdyAtIG1heFNlZ21lbnREdXJhdGlvbiAtIHByZXNlbnRhdGlvblN0YXJ0VGltZSk7XG4gIH1cblxuXG4gIHByaXZhdGUgY3JlYXRlTWVkaWFTdGF0ZV8gKFxuICAgICAgdHlwZTogTWVkaWFUeXBlLCBzdHJlYW06IElSZXByZXNlbnRhdGlvbikgOiBNZWRpYVN0YXRlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZSxcbiAgICAgIHN0cmVhbSxcbiAgICAgIG5lZWRJbml0OiB0cnVlLFxuICAgICAgbGFzdFNlZ21lbnQ6IG51bGwsXG4gICAgICB1cGRhdGluZzogZmFsc2UsXG4gICAgICBzY2hlZHVsZVRpbWVyOiBudWxsXG4gICAgfTtcbiAgfVxufSIsImltcG9ydCB7IElTZWdtZW50LCBJU2VnbWVudEluZGV4IH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlZ21lbnQgaW5kZXguXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWdtZW50SW5kZXggaW1wbGVtZW50cyBJU2VnbWVudEluZGV4IHtcbiAgcHJpdmF0ZSBzZWdtZW50c186IElTZWdtZW50W107XG5cbiAgY29uc3RydWN0b3IgKHNlZ21lbnRzOiBJU2VnbWVudFtdKSB7XG4gICAgdGhpcy5zZWdtZW50c18gPSBzZWdtZW50cztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCBBbGwgc2VnbWVudHMgaW4gdGhpcyBpbmRleC5cbiAgICogQHJldHVybnMgQWxsIHNlZ21lbnRzIGluIHRoZSBpbmRleC5cbiAgICovXG4gIGdldFNlZ21lbnRzICgpIDogSVNlZ21lbnRbXSB7XG4gICAgcmV0dXJuIHRoaXMuc2VnbWVudHNfO1xuICB9XG5cblxuICAvKipcbiAgICogQWRkIG5ldyBzZWdtZW50IHRvIHRoZSBpbmRleC5cbiAgICogQHBhcmFtIG5ld1NlZ21lbnRzXG4gICAqL1xuICBtZXJnZSAobmV3U2VnbWVudHM6IElTZWdtZW50W10pIDogdm9pZCB7XG4gICAgaWYgKG5ld1NlZ21lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50RW5kVGltZSA9IHRoaXMuZ2V0RW5kVGltZSh0cnVlKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdDdXJyZW50IHRpbWVsaW5lIGVuZDonLCBjdXJyZW50RW5kVGltZSk7XG5cbiAgICAvLyBFeHRlbmQgY3VycmVudCBpbmRleCB3aXRoIG5ldyBzZWdtZW50c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5ld1NlZ21lbnQgPSBuZXdTZWdtZW50c1tpXTtcbiAgICAgIGlmIChuZXdTZWdtZW50LnVuc2NhbGVkU3RhcnQgPj0gY3VycmVudEVuZFRpbWUpIHtcbiAgICAgICAgdGhpcy5zZWdtZW50c18ucHVzaChuZXdTZWdtZW50KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXG4gICAgICAgIC8vICAgJ0FkZGVkIG5ldyBzZWdtZW50IHRvIGluZGV4LiBTdGFydDonLCBuZXdTZWdtZW50LnVuc2NhbGVkU3RhcnQsXG4gICAgICAgIC8vICAgJ0VuZDonLCAobmV3U2VnbWVudC51bnNjYWxlZFN0YXJ0ICsgbmV3U2VnbWVudC51bnNjYWxlZER1cmF0aW9uKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzQ29udGlndW91cyh0aGlzLnNlZ21lbnRzXykpIHtcbiAgICAgIGNvbnNvbGUud2FybignVGhlIHNlZ21lbnQgdGltZWxpbmUgaXMgbm90IGNvbnRpZ3VvdXMuICcgK1xuICAgICAgICAnVGhpcyBtaWdodCBsZWFkIHRvIHBsYXliYWNrIGlzc3VlcycpXG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogU2VhcmNoIHRoZSBpbmRleCBmb3IgYSBzZWdtZW50IHRoYXQgY29udGFpbnMgdGhlIHByb3ZpZGVkbiB8dGltZXwuXG4gICAqXG4gICAqIEBwYXJhbSB0aW1lXG4gICAqIEByZXR1cm5zIFRoZSBzZWdtZW50IHRoYXQgY29udGFpbnMgfHRpbWV8IG9yIG51bGwuXG4gICAqL1xuICBmaW5kICh0aW1lOiBudW1iZXIpIDogSVNlZ21lbnQgfCBudWxsIHtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgdGhpcy5zZWdtZW50c18pIHtcbiAgICAgIGlmICgoc2VnbWVudC5zdGFydCA8PSB0aW1lKSAmJiAodGltZSA8IHNlZ21lbnQuZW5kKSkge1xuICAgICAgICByZXR1cm4gc2VnbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdDb3VsZCBub3QgZmluZCBzZWdtZW50IGZvciB0aW1lOicgKyB0aW1lICsgJy4nLFxuICAgICAgICAnU2VnbWVudCBjb3VudDogJyArICh0aGlzLnNlZ21lbnRzXy5sZW5ndGggLSAxKSxcbiAgICAgICAgJ0xhc3QgZW5kOiAnICsgdGhpcy5nZXRFbmRUaW1lKCkpO1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGluZGV4IHN0YXJ0IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB1bnNjYWxlZCBXaGV0aGVyIG9yIG5vdCB0aGUgcmV0dXJuIHRoZSB1bnNjYWxlZCB0aW1lXG4gICAqIEByZXR1cm5zIFN0YXJ0IHRpbWUuXG4gICAqL1xuICBnZXRTdGFydFRpbWUgKHVuc2NhbGVkPzogYm9vbGVhbikgOiBudW1iZXIge1xuICAgIGlmICh0aGlzLnNlZ21lbnRzXy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXMuc2VnbWVudHNfW3RoaXMuc2VnbWVudHNfLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuICh1bnNjYWxlZCA/IGZpcnN0LnN0YXJ0IDogZmlyc3QudW5zY2FsZWRTdGFydCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0IHRoZSBpbmRleCBlbmQgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHVuc2NhbGVkIFdoZXRoZXIgb3Igbm90IHRoZSByZXR1cm4gdGhlIHVuc2NhbGVkIHRpbWVcbiAgICogQHJldHVybnMgRW5kIHRpbWUuXG4gICAqL1xuICBnZXRFbmRUaW1lICh1bnNjYWxlZD86IGJvb2xlYW4pIDogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5zZWdtZW50c18ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGFzdCA9IHRoaXMuc2VnbWVudHNfW3RoaXMuc2VnbWVudHNfLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHVuc2NhbGVkID8gbGFzdC51bnNjYWxlZEVuZCA6IGxhc3QuZW5kO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEV2aWN0cyBzZWdtZW50IGZyb20gdGhlIGluZGV4LCB0aGF0IGhhdmUgZmFsbGVuIG91dCBvZiB0aGUgcHJvdmlkZWRcbiAgICogd2luZG93IGxlbmd0aC5cbiAgICpcbiAgICogQHBhcmFtIGR2cldpbmRvd0xlbmd0aCBEVlIgd2luZG93IGxlbmd0aFxuICAgKi9cbiAgYWRqdXN0RHZyV2luZG93IChkdnJXaW5kb3dMZW5ndGg6IG51bWJlcikgOiB2b2lkIHtcbiAgICBjb25zdCB3aW5kb3dTdGFydCA9IHRoaXMuZ2V0RW5kVGltZSgpIC0gZHZyV2luZG93TGVuZ3RoO1xuXG4gICAgY29uc3Qgb2xkU2l6ZSA9IHRoaXMuc2VnbWVudHNfLmxlbmd0aDtcblxuICAgIHRoaXMuc2VnbWVudHNfID1cbiAgICAgICAgdGhpcy5zZWdtZW50c18uZmlsdGVyKHNlZ21lbnQgPT4gc2VnbWVudC5lbmQgPiB3aW5kb3dTdGFydCk7XG5cbiAgICBjb25zdCBuZXdTaXplID0gdGhpcy5zZWdtZW50c18ubGVuZ3RoO1xuXG4gICAgY29uc29sZS5sb2coJ0V2aWN0ZWQgJyArIChvbGRTaXplIC0gbmV3U2l6ZSkgKyAnIHNlZ21lbnRzLicpO1xuICB9XG5cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBtZWRpYSBzZWdtZW50cyBjb25zdGl0dXRlIGEgY29udGlndW91cyB0aW1lbGluZS5cbiAgICpcbiAgICogQHBhcmFtIHNlZ21lbnRzIEFycmF5IG9mIG1lZGlhIHNlZ21lbnRzXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGltZWxpbmUgaXMgY29udGlndW91cywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNDb250aWd1b3VzIChzZWdtZW50czogSVNlZ21lbnRbXSkgOiBib29sZWFuIHtcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHJldiA9IHNlZ21lbnRzW2kgLSAxXTtcbiAgICAgIGNvbnN0IGN1cnIgPSBzZWdtZW50c1tpXTtcbiAgICAgIGNvbnN0IHByZXZFbmQgPSBwcmV2LnVuc2NhbGVkU3RhcnQgKyBwcmV2LnVuc2NhbGVkRHVyYXRpb247XG5cbiAgICAgIGlmIChjdXJyLnVuc2NhbGVkU3RhcnQgLSBwcmV2RW5kICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0aW1lbGluZSBmb3JtZWQgYnkgdGhlIHNlZ21lbnRzIGN1cnJlbnRseSBpbiB0aGUgaW5kZXhcbiAgICogaW5jbHVkZXMgdGhlIHByb3ZpZGVkIHx0aW1lfC5cbiAgICogQHBhcmFtIHRpbWUgVGltZSB0byBjaGVja1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIHx0aW1lfCBpbiBzZWdtZW50IHRpbWVsaW5lLlxuICAgKi9cbiAgaGFzVGltZSAodGltZTogbnVtYmVyKSA6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGZpcnN0U2VnbWVudCA9IHRoaXMuc2VnbWVudHNfWzBdO1xuICAgIGNvbnN0IGxhc3RTZWdtZW50ID0gdGhpcy5zZWdtZW50c19bdGhpcy5zZWdtZW50c18ubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgZmlyc3RTZWdtZW50U3RhcnQgPSBmaXJzdFNlZ21lbnQuc3RhcnQ7XG4gICAgY29uc3QgbGFzdFNlZ21lbnRFbmQgPSBsYXN0U2VnbWVudC5lbmQ7XG5cbiAgICByZXR1cm4gKGZpcnN0U2VnbWVudFN0YXJ0IDw9IHRpbWUpICYmICh0aW1lIDw9IGxhc3RTZWdtZW50RW5kKTtcbiAgfVxufVxuIiwiXG5pbXBvcnQgeyBQYXJzZXJVdGlscyBhcyBVdGlscyB9IGZyb20gJy4vcGFyc2VyLXV0aWxzJztcbmltcG9ydCB7IFNlZ21lbnRJbmRleCB9IGZyb20gJy4vc2VnbWVudC1pbmRleCc7XG5pbXBvcnQgeyBUaW1lciB9IGZyb20gJy4uL3V0aWxzL3RpbWVyJztcbmltcG9ydCB7IE5ldHdvcmtIYW5kbGUsIEh0dHBSZXF1ZXN0IH0gZnJvbSAnLi4vdXRpbHMvbmV0d29yayc7XG5pbXBvcnQgeyBJVGltZXIgfSBmcm9tICcuLi91dGlscy90eXBlcyc7XG5pbXBvcnQge1xuICBJU2VnbWVudCxcbiAgSVJlcHJlc2VudGF0aW9uLFxuICBJTWFuaWZlc3QsXG4gIElNYW5pZmVzdFBhcnNlcixcbiAgTWVkaWFUeXBlLFxuICBTdHJlYW1UeXBlXG59IGZyb20gJy4vdHlwZXMnO1xuXG5cbnR5cGUgQWRhcHRhdGlvblNldENvbnRleHQgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIG1pbWVUeXBlOiBzdHJpbmc7XG4gIGNvbnRlbnRUeXBlOiBzdHJpbmc7XG4gIGNvZGVjczogc3RyaW5nO1xuICBzZWdtZW50VGVtcGxhdGU6IEVsZW1lbnQ7XG59XG5cblxudHlwZSBSZXByZXNlbnRhdGlvbkNvbnRleHQgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIGJhbmR3aWR0aDogbnVtYmVyO1xuICBhZGFwdGF0aW9uU2V0OiBBZGFwdGF0aW9uU2V0Q29udGV4dDtcbn1cblxuXG50eXBlIE1lZGlhRGF0YUNvbnRleHQgPSB7XG4gIHN0YXJ0TnVtYmVyOiBudW1iZXI7XG4gIHNlZ21lbnREdXJhdGlvbjogbnVtYmVyO1xuICB0aW1lT2Zmc2V0OiBudW1iZXI7XG4gIHRpbWVzY2FsZTogbnVtYmVyO1xuICBpbml0aWFsaXphdGlvbkF0dHI6IHN0cmluZztcbiAgbWVkaWFBdHRyOiBzdHJpbmc7XG4gIHJlcHJlc2VudGF0aW9uOiBSZXByZXNlbnRhdGlvbkNvbnRleHQ7XG59XG5cblxudHlwZSBBbGxTZWdtZW50cyA9IHtcbiAgaW5pdFNlZ21lbnQ6IElTZWdtZW50O1xuICBtZWRpYVNlZ21lbnRzOiBJU2VnbWVudFtdO1xufVxuXG4vKipcbiAqIEEgTVBFRy1EQVNIIE1hbmlmZXN0IHBhcnNlci5cbiAqXG4gKiBUaGUgcGFyc2VyIGlzIHRhaWxvcmVkIHRvIGNvbnN1bWUgWmF0dG9vIExpdmUgc3RyZWFtIHdpdGggcmVzcGVjdCBvZiB0aGVcbiAqIHNjb3BlIG9mIHRoZSBjYXNlIHN0dWR5LiBNUEVHLURBU0ggZmVhdHVyZSBiZXlvbmQgdGhlIHNjb3BlIG9mIHRoZSBjYXNlXG4gKiBzdHVkeSBtYXkgbm90IGJlIHN1cHBvcnRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hbmlmZXN0UGFyc2VyIGltcGxlbWVudHMgSU1hbmlmZXN0UGFyc2VyIHtcbiAgcHJpdmF0ZSBtYW5pZmVzdFVybF86IHN0cmluZztcbiAgcHJpdmF0ZSBtYW5pZmVzdF86IElNYW5pZmVzdCB8IG51bGw7XG4gIHByaXZhdGUgbWF4U2VnbWVudER1cmF0aW9uXzogbnVtYmVyO1xuICBwcml2YXRlIHByZXNlbnRhdGlvbkR1cmF0aW9uXzogbnVtYmVyIHwgbnVsbDtcbiAgcHJpdmF0ZSBzdHJlYW1NYXBfOiBNYXA8TWVkaWFUeXBlLCBJUmVwcmVzZW50YXRpb25bXT47XG4gIHByaXZhdGUgZ2xvYmFsSWRfOiAwO1xuICBwcml2YXRlIHJlZnJlc2hUaW1lcl86IElUaW1lcjtcblxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLm1hbmlmZXN0VXJsXyA9ICcnO1xuICAgIHRoaXMubWFuaWZlc3RfID0gbnVsbDtcbiAgICB0aGlzLm1heFNlZ21lbnREdXJhdGlvbl8gPSAtMTtcbiAgICB0aGlzLnByZXNlbnRhdGlvbkR1cmF0aW9uXyA9IG51bGw7XG4gICAgdGhpcy5zdHJlYW1NYXBfID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZ2xvYmFsSWRfID0gMDtcbiAgICB0aGlzLnJlZnJlc2hUaW1lcl8gPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5yZWZyZXNoTWFuaWZlc3RfKCkpXG4gIH1cblxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHBhcnNlci4gVGhpcyBtZXRob2Qgd2lsbCBsb2FkIGFuZCBwYXJzZSB0aGUgbWFuaWZlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBtYW5pZmVzdFVybCBUaGUgbWFuaWZlc3QgVVJMXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgcGFyc2VkIG1hbmlmZXN0LlxuICAgKi9cbiAgYXN5bmMgc3RhcnQgKG1hbmlmZXN0VXJsOiBzdHJpbmcpIDogUHJvbWlzZTxJTWFuaWZlc3Q+IHtcbiAgICBjb25zb2xlLmxvZygnTWFuaWZlc3QgcGFyc2VyIHN0YXJ0cy4uLicpO1xuXG4gICAgdGhpcy5tYW5pZmVzdFVybF8gPSBtYW5pZmVzdFVybDtcblxuICAgIHRoaXMubWFuaWZlc3RfID0gYXdhaXQgdGhpcy5sb2FkQW5kUGFyc2VNYW5pZmVzdF8oKTtcblxuICAgIGlmICh0aGlzLm1hbmlmZXN0Xy50eXBlID09PSBTdHJlYW1UeXBlLkxJVkUpIHtcbiAgICAgIHRoaXMucmVmcmVzaFRpbWVyXy50aWNrQWZ0ZXIodGhpcy5tYW5pZmVzdF8ubWluVXBkYXRlUGVyaW9kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tYW5pZmVzdF87XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTdG9wIHBhcnNpbmcuXG4gICAqL1xuICBhc3luYyBzdG9wICgpIDogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coJ01hbmlmZXN0IHBhcnNlciBzdG9wcy4uLicpO1xuICAgIHRoaXMucmVmcmVzaFRpbWVyXy5jbGVhcigpO1xuICAgIHRoaXMuZ2xvYmFsSWRfID0gMDtcbiAgICB0aGlzLnN0cmVhbU1hcF8uY2xlYXIoKTtcbiAgICB0aGlzLm1heFNlZ21lbnREdXJhdGlvbl8gPSAtMTtcbiAgfVxuXG5cbiAgcHJpdmF0ZSBhc3luYyBsb2FkQW5kUGFyc2VNYW5pZmVzdF8gKCkgOiBQcm9taXNlPElNYW5pZmVzdD4ge1xuICAgIGxldCByZXEgPSBuZXcgSHR0cFJlcXVlc3QodGhpcy5tYW5pZmVzdFVybF8pO1xuICAgIHJlcS5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG5cbiAgICBjb25zdCByZXNwb25lID0gYXdhaXQgTmV0d29ya0hhbmRsZS5mZXRjaChyZXEpO1xuICAgIGNvbnN0IG1wZCA9IFV0aWxzLnBhcnNlWG1sKHJlc3BvbmUuZGF0YSBhcyBzdHJpbmcpO1xuXG4gICAgaWYgKCFtcGQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBNYW5pZmVzdCcpO1xuICAgIH1cblxuICAgIHRoaXMucHJlc2VudGF0aW9uRHVyYXRpb25fID1cbiAgICAgICAgVXRpbHMucGFyc2VJc29EdXJhdGlvbihcbiAgICAgICAgICAgIG1wZC5nZXRBdHRyaWJ1dGUoJ21lZGlhUHJlc2VudGF0aW9uRHVyYXRpb24nKSB8fCAnJykgfHwgbnVsbDtcbiAgICBjb25zdCBwcmVzZW50YXRpb25UeXBlID0gbXBkLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgIGNvbnN0IG1pbkJ1ZmZlclRpbWUgPVxuICAgICAgICBVdGlscy5wYXJzZUlzb0R1cmF0aW9uKG1wZC5nZXRBdHRyaWJ1dGUoJ21pbkJ1ZmZlclRpbWUnKSB8fCAnJykgfHwgLTE7XG4gICAgY29uc3QgcHJlc2VudGF0aW9uU3RhcnRUaW1lID1cbiAgICAgICAgVXRpbHMucGFyc2VEYXRlKG1wZC5nZXRBdHRyaWJ1dGUoJ2F2YWlsYWJpbGl0eVN0YXJ0VGltZScpIHx8ICcnKSB8fCAwO1xuICAgIGNvbnN0IHN1Z2dlc3RlZFByZXNlbnRhdGlvbkRlbGF5ID1cbiAgICAgICAgVXRpbHMucGFyc2VJc29EdXJhdGlvbihcbiAgICAgICAgICAgIG1wZC5nZXRBdHRyaWJ1dGUoJ3N1Z2dlc3RlZFByZXNlbnRhdGlvbkRlbGF5JykgfHwgJycpO1xuICAgIGNvbnN0IG1pbmltdW1VcGRhdGVQZXJpb2QgPVxuICAgICAgICBVdGlscy5wYXJzZUlzb0R1cmF0aW9uXG4gICAgICAgICAgICAobXBkLmdldEF0dHJpYnV0ZSgnbWluaW11bVVwZGF0ZVBlcmlvZCcpIHx8ICcnKSB8fCAtMTtcbiAgICBjb25zdCBkdnJXaW5kb3dMZW5ndGggPVxuICAgICAgICBVdGlscy5wYXJzZUlzb0R1cmF0aW9uKFxuICAgICAgICAgICAgbXBkLmdldEF0dHJpYnV0ZSgndGltZVNoaWZ0QnVmZmVyRGVwdGgnKSB8fCAnJykgfHwgSW5maW5pdHk7XG4gICAgbGV0IHByZXNlbnRhdGlvbkRlbGF5ID0gbnVsbDtcblxuICAgIGNvbnN0IHBlcmlvZE5vZGVzID0gVXRpbHMuZ2V0Q2hpbGRyZW4obXBkLCAnUGVyaW9kJyk7XG5cbiAgICBpZiAocGVyaW9kTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdObyBwZXJpb2QgZm91bmQnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYW5pZmVzdDogbm8gcGVyaW9kIGZvdW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKHBlcmlvZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnTXVsdGktcGVyaW9kIG1hbmlmZXN0cyBub3Qgc3VwcG9ydGVkLiAnICtcbiAgICAgICAgICAnQWRkaXRpb25hbCBwZXJpb2RzIHdpbGwgYmUgaWdub3JlZC4uLicpO1xuICAgIH1cblxuICAgIC8vIE11bHRpLXBlcmlvZCBub3Qgc3VwcG9ydGVkIHlldCFcbiAgICBjb25zdCBwZXJpb2QgPSBwZXJpb2ROb2Rlc1swXTtcbiAgICBjb25zdCBwZXJpb2REdXJhdGlvbiA9XG4gICAgICAgIFV0aWxzLnBhcnNlSXNvRHVyYXRpb24ocGVyaW9kLmdldEF0dHJpYnV0ZSgnZHVyYXRpb24nKSB8fCAnJykgfHwgbnVsbDtcblxuICAgIGlmICghdGhpcy5wcmVzZW50YXRpb25EdXJhdGlvbl8pIHtcbiAgICAgIGlmIChwZXJpb2REdXJhdGlvbikge1xuICAgICAgICB0aGlzLnByZXNlbnRhdGlvbkR1cmF0aW9uXyA9IHBlcmlvZER1cmF0aW9uO1xuICAgICAgfSBlbHNlIGlmIChwcmVzZW50YXRpb25UeXBlID09PSAnZHluYW1pYycpIHtcbiAgICAgICAgdGhpcy5wcmVzZW50YXRpb25EdXJhdGlvbl8gPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucHJlc2VudGF0aW9uRHVyYXRpb25fKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgcHJlc2VudGF0aW9uIGR1cmF0aW9uIScpO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLSBQZXJpb2QgbWlnaHQgY29udGFpbiBzZWdtZW50IGluZm9zXG5cbiAgICBjb25zdCBhZGFwdGF0aW9uU2V0Tm9kZXMgPVxuICAgICAgICBVdGlscy5nZXRDaGlsZHJlbihwZXJpb2QsICdBZGFwdGF0aW9uU2V0Jyk7XG5cbiAgICBhZGFwdGF0aW9uU2V0Tm9kZXMuZm9yRWFjaCh0aGlzLnBhcnNlQWRhcHRhdGlvblNldF8uYmluZCh0aGlzKSk7XG5cbiAgICBpZiAoc3VnZ2VzdGVkUHJlc2VudGF0aW9uRGVsYXkpIHtcbiAgICAgIHByZXNlbnRhdGlvbkRlbGF5ID0gc3VnZ2VzdGVkUHJlc2VudGF0aW9uRGVsYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICAgIHRoaXMubWF4U2VnbWVudER1cmF0aW9uXyA+IDAsXG4gICAgICAgICAgJ0J1ZzogU2hvdWxkIGhhdmUgc2V0IG1heCBzZWdtZW50IGR1cmF0aW9uIScpO1xuICAgICAgcHJlc2VudGF0aW9uRGVsYXkgPSBNYXRoLnJvdW5kKHRoaXMubWF4U2VnbWVudER1cmF0aW9uXyAqIDMpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hbmlmZXN0IDogSU1hbmlmZXN0ID0ge1xuICAgICAgdHlwZTogcHJlc2VudGF0aW9uVHlwZSA9PT0gJ2R5bmFtaWMnID8gU3RyZWFtVHlwZS5MSVZFIDogU3RyZWFtVHlwZS5WT0QsXG4gICAgICBzdGFydFRpbWU6IHByZXNlbnRhdGlvblN0YXJ0VGltZSxcbiAgICAgIGRlbGF5OiBwcmVzZW50YXRpb25EZWxheSxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLnByZXNlbnRhdGlvbkR1cmF0aW9uXyxcbiAgICAgIGR2cldpbmRvd0xlbmd0aCxcbiAgICAgIG1pbkJ1ZmZlclRpbWUsXG4gICAgICBtaW5VcGRhdGVQZXJpb2Q6IG1pbmltdW1VcGRhdGVQZXJpb2QsXG4gICAgICBtYXhTZWdtZW50RHVyYXRpb246IHRoaXMubWF4U2VnbWVudER1cmF0aW9uXyxcbiAgICAgIHZpZGVvOiB0aGlzLnN0cmVhbU1hcF8uZ2V0KE1lZGlhVHlwZS5WSURFTykgfHwgW10sXG4gICAgICBhdWRpbzogdGhpcy5zdHJlYW1NYXBfLmdldChNZWRpYVR5cGUuQVVESU8pIHx8IFtdXG4gICAgfTtcblxuICAgIC8vIFdlIGRvbmUgcGFyc2luZyBjbGVhciBzdHJlYW0gbWFwXG4gICAgdGhpcy5zdHJlYW1NYXBfLmNsZWFyKCk7XG5cbiAgICByZXR1cm4gbWFuaWZlc3Q7XG4gIH1cblxuXG4gIHByaXZhdGUgcGFyc2VBZGFwdGF0aW9uU2V0XyAoZWxlbTogRWxlbWVudCkgOiB2b2lkIHtcbiAgICBjb25zdCBpZCA9IGVsZW0uZ2V0QXR0cmlidXRlKCdpZCcpIHx8IFN0cmluZyh0aGlzLmdsb2JhbElkXysrKTtcbiAgICBjb25zdCBtaW1lVHlwZSA9IGVsZW0uZ2V0QXR0cmlidXRlKCdtaW1lVHlwZScpIHx8ICcnO1xuICAgIGNvbnN0IGNvZGVjcyA9IGVsZW0uZ2V0QXR0cmlidXRlKCdjb2RlY3MnKSB8fCAnJztcbiAgICBjb25zdCBjb250ZW50VHlwZSA9XG4gICAgICAgIGVsZW0uZ2V0QXR0cmlidXRlKCdjb250ZW50VHlwZScpIHx8IFV0aWxzLmdldFR5cGVGcm9tTWltZVR5cGUobWltZVR5cGUpO1xuICAgIGNvbnN0IHNlZ21lbnRUZW1wbGF0ZSA9IFV0aWxzLmdldEZpcnN0Q2hpbGQoZWxlbSwgJ1NlZ21lbnRUZW1wbGF0ZScpO1xuICAgIGNvbnN0IHNlZ21lbnRCYXNlID0gVXRpbHMuZ2V0Rmlyc3RDaGlsZChlbGVtLCAnU2VnbWVudEJhc2UnKTtcbiAgICBjb25zdCBzZWdtZW50TGlzdCA9IFV0aWxzLmdldEZpcnN0Q2hpbGQoZWxlbSwgJ1NlZ21lbnRMaXN0Jyk7XG5cbiAgICAvLyBXZSBvbmx5IHBhcnNlIHZpZGVvIGFuZCBhdWRpbyBzdHJlYW1zIVxuICAgIGlmIChjb250ZW50VHlwZSAhPT0gTWVkaWFUeXBlLlZJREVPICYmIGNvbnRlbnRUeXBlICE9PSBNZWRpYVR5cGUuQVVESU8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VnbWVudEJhc2UgfHwgc2VnbWVudExpc3QpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ3VycmVudGx5IG9ubHkgU2VnbWVudFRlbXBsYXRlIGlzIHN1cHBvcnRlZCEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXNlZ21lbnRUZW1wbGF0ZSkge1xuICAgICAgY29uc29sZS5lcnJvcignTm8gc3VwcG9ydCBmb3IgbWFuaWZlc3QgdHlwZSEnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnT25seSBEQVNIIG1hbmlmZXN0IHdpdGggc2VnbWVudCB0ZW1wbGF0ZSBhcmUgc3VwcG9ydGVkIScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cmVhbU1hcF8uaGFzKGNvbnRlbnRUeXBlKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSBhZGFwdGF0aW9uIHNldHMgZm9yIHNhbWUgY29udGVudCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuLi4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXByZXNlbnRhdGlvbk5vZGVzID0gVXRpbHMuZ2V0Q2hpbGRyZW4oZWxlbSwgJ1JlcHJlc2VudGF0aW9uJyk7XG4gICAgY29uc3Qgc3RyZWFtcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCByZXByZXNlbnRhdGlvbk5vZGUgb2YgcmVwcmVzZW50YXRpb25Ob2Rlcykge1xuICAgICAgY29uc3QgY29udGV4dCA6IEFkYXB0YXRpb25TZXRDb250ZXh0ID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgbWltZVR5cGUsXG4gICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICBjb2RlY3MsXG4gICAgICAgIHNlZ21lbnRUZW1wbGF0ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VSZXByZXNlbnRhdGlvbl8ocmVwcmVzZW50YXRpb25Ob2RlLCBjb250ZXh0KTtcblxuICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICBzdHJlYW1zLnB1c2gocGFyc2VkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyZWFtcy5sZW5ndGggPCAxKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFbXB0eSBBZGFwdGF0aW9uU2V0IScpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIG1hbmlmZXN0OiBubyByZXByZXNlbmF0aW9uIGZvdW5kIGZvciAke2NvbnRlbnRUeXBlfWApXG4gICAgfVxuXG4gICAgdGhpcy5zdHJlYW1NYXBfLnNldChjb250ZW50VHlwZSwgc3RyZWFtcyk7XG4gIH1cblxuXG4gIHByaXZhdGUgcGFyc2VSZXByZXNlbnRhdGlvbl8gKFxuICAgICAgZWxlbTogRWxlbWVudCwgY29udGV4dDogQWRhcHRhdGlvblNldENvbnRleHQpIDogSVJlcHJlc2VudGF0aW9uIHtcbiAgICBjb25zdCBvcmlnaW5hbElkID0gZWxlbS5nZXRBdHRyaWJ1dGUoJ2lkJykgfHwgJyc7XG4gICAgY29uc3QgYmFuZHdpZHRoID0gTnVtYmVyKGVsZW0uZ2V0QXR0cmlidXRlKCdiYW5kd2lkdGgnKSk7XG4gICAgY29uc3Qgd2lkdGggPSBOdW1iZXIoZWxlbS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO1xuICAgIGNvbnN0IGhlaWdodCA9IE51bWJlcihlbGVtLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO1xuICAgIGNvbnN0IGNvZGVjcyA9IGVsZW0uZ2V0QXR0cmlidXRlKCdjb2RlY3MnKSB8fCBjb250ZXh0LmNvZGVjcztcbiAgICBjb25zdCBmcmFtZVJhdGUgPSBOdW1iZXIoZWxlbS5nZXRBdHRyaWJ1dGUoJ2ZyYW1lUmF0ZScpKTtcbiAgICBjb25zdCBzZWdtZW50VGVtcGxhdGUgPVxuICAgICAgICBVdGlscy5nZXRGaXJzdENoaWxkKGVsZW0sICdTZWdtZW50VGVtcGxhdGUnKSB8fCBjb250ZXh0LnNlZ21lbnRUZW1wbGF0ZTtcblxuICAgIGNvbnN0IHJDb250ZXh0OiBSZXByZXNlbnRhdGlvbkNvbnRleHQgPSB7XG4gICAgICBpZDogb3JpZ2luYWxJZCxcbiAgICAgIGJhbmR3aWR0aCxcbiAgICAgIGFkYXB0YXRpb25TZXQ6IGNvbnRleHRcbiAgICB9O1xuXG4gICAgY29uc3QgbWVkaWFEYXRhID0gdGhpcy5wYXJzZVNlZ21lbnRUZW1wbGF0ZV8oc2VnbWVudFRlbXBsYXRlLCByQ29udGV4dCk7XG5cbiAgICBjb25zb2xlLmFzc2VydChcbiAgICAgICAgbWVkaWFEYXRhLm1lZGlhU2VnbWVudHMubGVuZ3RoID4gMCwgJ1Nob3VsZCBoYXZlIHBhcnNlZCBzZWdtZW50cycpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRPRE9cbiAgICAgIGlkOiBjb250ZXh0LmNvbnRlbnRUeXBlICsgJ18nICsgY29udGV4dC5pZCArICdfJyArIChvcmlnaW5hbElkID8gb3JpZ2luYWxJZCA6IFN0cmluZyh0aGlzLmdsb2JhbElkXysrKSksXG4gICAgICBvcmlnaW5hbElkLFxuICAgICAgdHlwZTogKGNvbnRleHQuY29udGVudFR5cGUgYXMgTWVkaWFUeXBlKSxcbiAgICAgIGticHM6IGJhbmR3aWR0aCAvIDEwMDAsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGZyYW1lUmF0ZSxcbiAgICAgIGNvZGVjcyxcbiAgICAgIG1pbWVUeXBlOiBjb250ZXh0Lm1pbWVUeXBlLFxuICAgICAgaW5pdGlhbGl6YXRpb246IG1lZGlhRGF0YS5pbml0U2VnbWVudCxcbiAgICAgIHNlZ21lbnRJbmRleDogbmV3IFNlZ21lbnRJbmRleChtZWRpYURhdGEubWVkaWFTZWdtZW50cylcbiAgICB9XG4gIH1cblxuXG4gIHByaXZhdGUgcGFyc2VTZWdtZW50VGVtcGxhdGVfIChcbiAgICAgIGVsZW06IEVsZW1lbnQsIGNvbnRleHQ6IFJlcHJlc2VudGF0aW9uQ29udGV4dCkgOiBBbGxTZWdtZW50cyB7XG4gICAgLy8gU2VjdGlvbiA1LjMuOS4yLjJcbiAgICBjb25zdCBwcmVzZW50YXRpb25UaW1lT2Zmc2V0ID1cbiAgICAgICAgTnVtYmVyKGVsZW0uZ2V0QXR0cmlidXRlKCdwcmVzZW50YXRpb25UaW1lT2Zmc2V0JykpO1xuICAgIGNvbnN0IHRpbWVzY2FsZSA9IE51bWJlcihlbGVtLmdldEF0dHJpYnV0ZSgndGltZXNjYWxlJykpIHx8IDE7XG4gICAgY29uc3Qgc2VnbWVudER1cmF0aW9uID0gTnVtYmVyKGVsZW0uZ2V0QXR0cmlidXRlKCdkdXJhdGlvbicpKSB8fCAtMTtcbiAgICBjb25zdCBpbml0aWFsaXphdGlvbiA9IGVsZW0uZ2V0QXR0cmlidXRlKCdpbml0aWFsaXphdGlvbicpIHx8ICcnO1xuICAgIGNvbnN0IG1lZGlhID0gZWxlbS5nZXRBdHRyaWJ1dGUoJ21lZGlhJykgfHwgJyc7XG4gICAgY29uc3Qgc3RhcnROdW1iZXIgPSBOdW1iZXIoZWxlbS5nZXRBdHRyaWJ1dGUoJ3N0YXJ0TnVtYmVyJykpIHx8IDE7XG4gICAgY29uc3Qgc2VnbWVudFRpbWVsaW5lID0gVXRpbHMuZ2V0Rmlyc3RDaGlsZChlbGVtLCAnU2VnbWVudFRpbWVsaW5lJyk7XG5cbiAgICBjb25zdCBtQ29udGV4dCA6IE1lZGlhRGF0YUNvbnRleHQgPSB7XG4gICAgICBzdGFydE51bWJlcixcbiAgICAgIHNlZ21lbnREdXJhdGlvbixcbiAgICAgIHRpbWVPZmZzZXQ6IHByZXNlbnRhdGlvblRpbWVPZmZzZXQsXG4gICAgICB0aW1lc2NhbGUsXG4gICAgICBpbml0aWFsaXphdGlvbkF0dHI6IGluaXRpYWxpemF0aW9uLFxuICAgICAgbWVkaWFBdHRyOiBtZWRpYSxcbiAgICAgIHJlcHJlc2VudGF0aW9uOiBjb250ZXh0XG4gICAgfTtcblxuICAgIC8vIFNlZ21lbnQgdGVtcGxhdGUgd2l0aCB0aW1lbGluZS5cbiAgICBpZiAoc2VnbWVudFRpbWVsaW5lKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVTZWdtZW50c0Zyb21UaW1lbGluZV8oc2VnbWVudFRpbWVsaW5lLCBtQ29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlU2VnbWVudHNGcm9tVGVtcGxhdGVfKG1Db250ZXh0KTtcbiAgfVxuXG5cbiAgcHJpdmF0ZSBjcmVhdGVTZWdtZW50c0Zyb21UZW1wbGF0ZV8gKFxuICAgICAgY29udGV4dDogTWVkaWFEYXRhQ29udGV4dCkgOiBBbGxTZWdtZW50cyB7XG4gICAgY29uc29sZS5hc3NlcnQoXG4gICAgICAgIGNvbnRleHQuc2VnbWVudER1cmF0aW9uID4gMCxcbiAgICAgICAgJ1NlZ21lbnQgdGVtcGxhdGUgd2l0aG91dCB0aW1lbGluZSBzaG91bGQgaGF2ZSBzZWdtZW50IGR1cmF0aW9uJyk7XG4gICAgaWYgKCF0aGlzLnByZXNlbnRhdGlvbkR1cmF0aW9uXykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByZXNlbnRhdGlvbiBkdXJhdGlvbiEnKTtcbiAgICB9XG4gICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgICBsZXQgcG9zaXRpb24gPSBjb250ZXh0LnN0YXJ0TnVtYmVyO1xuICAgIGxldCBzY2FsZWRTZWdtZW50RHVyYXRpb24gPSAgY29udGV4dC5zZWdtZW50RHVyYXRpb24gLyBjb250ZXh0LnRpbWVzY2FsZTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSBzY2FsZWRTZWdtZW50RHVyYXRpb247XG5cbiAgICAvLyBUT0RPXG4gICAgdGhpcy5tYXhTZWdtZW50RHVyYXRpb25fID0gZW5kIC0gc3RhcnQ7XG5cbiAgICB3aGlsZSAoZW5kIDwgdGhpcy5wcmVzZW50YXRpb25EdXJhdGlvbl8pIHtcbiAgICAgIGNvbnN0IHVuc2NhbGVkU3RhcnQgPSBzdGFydCAqIGNvbnRleHQudGltZXNjYWxlO1xuICAgICAgY29uc3QgdW5zY2FsZWRFbmQgPSBlbmQgKiBjb250ZXh0LnRpbWVzY2FsZTtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kLFxuICAgICAgICBkdXJhdGlvbjogZW5kIC0gc3RhcnQsXG4gICAgICAgIHVuc2NhbGVkU3RhcnQsXG4gICAgICAgIHVuc2NhbGVkRW5kLFxuICAgICAgICB1bnNjYWxlZER1cmF0aW9uOiB1bnNjYWxlZEVuZCAtIHVuc2NhbGVkU3RhcnQsXG4gICAgICAgIGlzSW5pdDogZmFsc2UsXG4gICAgICAgIHVybDogVXRpbHMucmVzb2x2ZVRlbXBsYXRlVXJsKFxuICAgICAgICAgIGNvbnRleHQubWVkaWFBdHRyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlcHJlc2VudGF0aW9uSWQ6IGNvbnRleHQucmVwcmVzZW50YXRpb24uaWQsXG4gICAgICAgICAgICBiYW5kd2lkdGg6IGNvbnRleHQucmVwcmVzZW50YXRpb24uYmFuZHdpZHRoLFxuICAgICAgICAgICAgdGltZTogdW5zY2FsZWRTdGFydCxcbiAgICAgICAgICAgIG51bWJlcjogcG9zaXRpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRoaXMubWFuaWZlc3RVcmxfKVxuICAgICAgfSk7XG5cbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgZW5kID0gTWF0aC5taW4odGhpcy5wcmVzZW50YXRpb25EdXJhdGlvbl8sIChlbmQgKyBzY2FsZWRTZWdtZW50RHVyYXRpb24pKTtcbiAgICAgICsrcG9zaXRpb247XG4gICAgfVxuXG4gICAgY29uc29sZS5hc3NlcnQoc2VnbWVudHMubGVuZ3RoID4gMCwgJ1Nob3VsZCBoYXZlIHNlZ21lbnRzISEhJyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaW5pdFNlZ21lbnQ6IHtcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogMCxcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgIHVuc2NhbGVkU3RhcnQ6IDAsXG4gICAgICAgIHVuc2NhbGVkRW5kOiAwLFxuICAgICAgICB1bnNjYWxlZER1cmF0aW9uOiAwLFxuICAgICAgICBpc0luaXQ6IHRydWUsXG4gICAgICAgIHVybDogVXRpbHMucmVzb2x2ZVRlbXBsYXRlVXJsKFxuICAgICAgICAgIGNvbnRleHQuaW5pdGlhbGl6YXRpb25BdHRyLCAvLyBJbml0IFVybCB0ZW1wbGF0ZVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlcHJlc2VudGF0aW9uSWQ6IGNvbnRleHQucmVwcmVzZW50YXRpb24uaWQsXG4gICAgICAgICAgICBiYW5kd2lkdGg6IGNvbnRleHQucmVwcmVzZW50YXRpb24uYmFuZHdpZHRoXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aGlzLm1hbmlmZXN0VXJsX1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgbWVkaWFTZWdtZW50czogc2VnbWVudHNcbiAgICB9XG4gIH1cblxuXG4gIHByaXZhdGUgY3JlYXRlU2VnbWVudHNGcm9tVGltZWxpbmVfIChcbiAgICAgIGVsZW06IEVsZW1lbnQsIGNvbnRleHQ6IE1lZGlhRGF0YUNvbnRleHQpIDogQWxsU2VnbWVudHMge1xuICAgIC8vIFNlY3Rpb24gNS4zLjkuNlxuICAgIGNvbnN0IHNOb2RlcyA9IFV0aWxzLmdldENoaWxkcmVuKGVsZW0sICdTJyk7XG4gICAgY29uc3QgbWVkaWFTZWdtZW50czogSVNlZ21lbnRbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBzTm9kZSBvZiBzTm9kZXMpIHtcbiAgICAgIGxldCBkID0gTnVtYmVyKHNOb2RlLmdldEF0dHJpYnV0ZSgnZCcpKTtcbiAgICAgIGxldCByID0gTnVtYmVyKHNOb2RlLmdldEF0dHJpYnV0ZSgncicpKTtcbiAgICAgIGxldCB0ID0gbnVsbDtcbiAgICAgIGxldCBzY2FsZWRUID0gbnVsbDtcbiAgICAgIGxldCBzY2FsZWREID0gZCAvIGNvbnRleHQudGltZXNjYWxlO1xuXG4gICAgICAvLyBUT0RPIC0gQXNzZXJ0IGhhcyBkdXJhdGlvblxuXG4gICAgICBpZiAoc05vZGUuaGFzQXR0cmlidXRlKCd0JykpIHtcbiAgICAgICAgdCA9IE51bWJlcihzTm9kZS5nZXRBdHRyaWJ1dGUoJ3QnKSkgLSBjb250ZXh0LnRpbWVPZmZzZXQ7XG4gICAgICB9IGVsc2UgaWYgKG1lZGlhU2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIElmIEB0IG5vdCBwcmVzZW50LCB0aGVuIHRoZSB2YWx1ZSBzaGFsbCBiZSBhc3N1bWVkIHplcm8gZm9yIHRoZVxuICAgICAgICAvLyBmaXJzdCBTIGVsZW1lbnQuXG4gICAgICAgIHQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgQHQgbm90IHByZXNlbnQsIGFuZCBub3QgdGhlIGZpcnN0IFMgZWxlbWVudCB0aGVuIHRoZSB2YWx1ZVxuICAgICAgICAvLyBzaGFsbCBiZSBhc3N1bWVkIHRvIGJlIHRoZSBzdW0gb2YgdGhlIHByZXZpb3VzIFMgZWxlbWVudCdzIGVhcmxpZXN0XG4gICAgICAgIC8vIHByZXNlbnRhdGlvbiB0aW1lIGFuZCBjb250aWd1b3VzIGR1cmF0aW9uIGkuZS4gZW5kIHRpbWUgZm9yIHByZXZpb3VzXG4gICAgICAgIC8vIHNlZ21lbnQuXG4gICAgICAgIGNvbnN0IGxhc3RTZWdtZW50ID0gbWVkaWFTZWdtZW50c1ttZWRpYVNlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0ID0gbGFzdFNlZ21lbnQudW5zY2FsZWRTdGFydCArIGxhc3RTZWdtZW50LnVuc2NhbGVkRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVuc2NhbGVkRW5kID0gdCArIGQ7XG5cbiAgICAgIHNjYWxlZFQgPSB0IC8gY29udGV4dC50aW1lc2NhbGU7XG5cbiAgICAgIC8vIFRPRE8gLSBDaGVjayBmb3IgZGlzY29udGludWl0eVxuICAgICAgaWYgKHRoaXMubWF4U2VnbWVudER1cmF0aW9uXyA8IHNjYWxlZEQpIHtcbiAgICAgICAgdGhpcy5tYXhTZWdtZW50RHVyYXRpb25fID0gc2NhbGVkRDtcbiAgICAgIH1cblxuICAgICAgbWVkaWFTZWdtZW50cy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IHNjYWxlZFQsXG4gICAgICAgIGVuZDogdW5zY2FsZWRFbmQgLyBjb250ZXh0LnRpbWVzY2FsZSxcbiAgICAgICAgZHVyYXRpb246IHNjYWxlZEQsXG4gICAgICAgIHVuc2NhbGVkU3RhcnQ6IHQsXG4gICAgICAgIHVuc2NhbGVkRW5kLFxuICAgICAgICB1bnNjYWxlZER1cmF0aW9uOiBkLFxuICAgICAgICBpc0luaXQ6IGZhbHNlLFxuICAgICAgICB1cmw6IFV0aWxzLnJlc29sdmVUZW1wbGF0ZVVybChcbiAgICAgICAgICBjb250ZXh0Lm1lZGlhQXR0ciwgLy8gdXJsIHRlbXBsYXRlXG4gICAgICAgICAgeyBiYW5kd2lkdGg6IGNvbnRleHQucmVwcmVzZW50YXRpb24uYmFuZHdpZHRoLCB0aW1lOiB0fSxcbiAgICAgICAgICB0aGlzLm1hbmlmZXN0VXJsXylcbiAgICAgIH0pO1xuXG4gICAgICBpZiAociA8IC0xKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTmVnYXRpdmUgcmVwZWF0IGNvdW50IG5vdCBzdXBwb3J0ZWQgYXQgdGhlIG1vbWVudCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAociA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGFzdFNlZ21lbnQgPSBtZWRpYVNlZ21lbnRzW21lZGlhU2VnbWVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBjb25zdCBuZXh0U3RhcnRVbnNjYWxlZCA9IGxhc3RTZWdtZW50LnVuc2NhbGVkRW5kO1xuICAgICAgICAgIGNvbnN0IG5leHRFbmRVbnNjYWxlZCA9IG5leHRTdGFydFVuc2NhbGVkICsgZDtcblxuICAgICAgICAgIG1lZGlhU2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogbGFzdFNlZ21lbnQuZW5kLFxuICAgICAgICAgICAgZW5kOiBuZXh0RW5kVW5zY2FsZWQgLyBjb250ZXh0LnRpbWVzY2FsZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzY2FsZWRELFxuICAgICAgICAgICAgdW5zY2FsZWRTdGFydDogbmV4dFN0YXJ0VW5zY2FsZWQsXG4gICAgICAgICAgICB1bnNjYWxlZEVuZDogbmV4dEVuZFVuc2NhbGVkLFxuICAgICAgICAgICAgdW5zY2FsZWREdXJhdGlvbjogZCxcbiAgICAgICAgICAgIGlzSW5pdDogZmFsc2UsXG4gICAgICAgICAgICB1cmw6IFV0aWxzLnJlc29sdmVUZW1wbGF0ZVVybChcbiAgICAgICAgICAgICAgY29udGV4dC5tZWRpYUF0dHIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiYW5kd2lkdGg6IGNvbnRleHQucmVwcmVzZW50YXRpb24uYmFuZHdpZHRoLFxuICAgICAgICAgICAgICAgIHRpbWU6IG5leHRTdGFydFVuc2NhbGVkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3RVcmxfKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXRTZWdtZW50OiB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IDAsXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICB1bnNjYWxlZFN0YXJ0OiAwLFxuICAgICAgICB1bnNjYWxlZEVuZDogMCxcbiAgICAgICAgdW5zY2FsZWREdXJhdGlvbjogMCxcbiAgICAgICAgaXNJbml0OiB0cnVlLFxuICAgICAgICB1cmw6IFV0aWxzLnJlc29sdmVUZW1wbGF0ZVVybChcbiAgICAgICAgICBjb250ZXh0LmluaXRpYWxpemF0aW9uQXR0ciwgLy8gSW5pdCBVcmwgdGVtcGxhdGVcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXByZXNlbnRhdGlvbklkOiBjb250ZXh0LnJlcHJlc2VudGF0aW9uLmlkLFxuICAgICAgICAgICAgYmFuZHdpZHRoOiBjb250ZXh0LnJlcHJlc2VudGF0aW9uLmJhbmR3aWR0aFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhpcy5tYW5pZmVzdFVybF9cbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIG1lZGlhU2VnbWVudHNcbiAgICB9O1xuXG4gIH1cblxuXG4gIHByaXZhdGUgYXN5bmMgcmVmcmVzaE1hbmlmZXN0XyAoKSA6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5tYW5pZmVzdF8pIHJldHVybjtcblxuICAgIGNvbnNvbGUubG9nKCdSZWZyZXNoaW5nIG1hbmlmZXN0Li4uJyk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV3TWFuaWZlc3QgPSBhd2FpdCB0aGlzLmxvYWRBbmRQYXJzZU1hbmlmZXN0XygpO1xuXG4gICAgICAvLyBUT0RPXG4gICAgICB0aGlzLm1hbmlmZXN0Xy5kdnJXaW5kb3dMZW5ndGggPSBuZXdNYW5pZmVzdC5kdnJXaW5kb3dMZW5ndGg7XG4gICAgICB0aGlzLm1hbmlmZXN0Xy5taW5VcGRhdGVQZXJpb2QgPSBuZXdNYW5pZmVzdC5taW5VcGRhdGVQZXJpb2Q7XG5cbiAgICAgIC8vIFVwZGF0ZSBzdHJlYW1zXG4gICAgICBpZiAodGhpcy5tYW5pZmVzdF8udmlkZW8gJiYgbmV3TWFuaWZlc3QudmlkZW8pIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdHJlYW1zXyhcbiAgICAgICAgICAgIHRoaXMubWFuaWZlc3RfLnZpZGVvLCBuZXdNYW5pZmVzdC52aWRlbyxcbiAgICAgICAgICAgIHRoaXMubWFuaWZlc3RfLmR2cldpbmRvd0xlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tYW5pZmVzdF8uYXVkaW8gJiYgbmV3TWFuaWZlc3QuYXVkaW8pIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdHJlYW1zXyhcbiAgICAgICAgICAgIHRoaXMubWFuaWZlc3RfLmF1ZGlvLCBuZXdNYW5pZmVzdC5hdWRpbyxcbiAgICAgICAgICAgIHRoaXMubWFuaWZlc3RfLmR2cldpbmRvd0xlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IE5vdGlmeSBuZXcgbWFuaWZlc3Q/XG5cbiAgICAgIC8vIFNjaGVkdWxlIG5leHQgdXBkYXRlXG4gICAgICB0aGlzLnJlZnJlc2hUaW1lcl8udGlja0FmdGVyKHRoaXMubWFuaWZlc3RfLm1pblVwZGF0ZVBlcmlvZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZWZyZXNoIG1hbmlmZXN0LCByZXRyeWluZy4uLicsIGVycm9yKTtcbiAgICAgIC8vIFJldHJ5XG4gICAgICB0aGlzLnJlZnJlc2hUaW1lcl8udGlja0FmdGVyKDApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU3RyZWFtc18gKFxuICAgICAgb2xkU3RyZWFtczogSVJlcHJlc2VudGF0aW9uW10sXG4gICAgICBuZXdTdHJlYW1zOiBJUmVwcmVzZW50YXRpb25bXSwgZHZyV2luZG93TGVuZ3RoOiBudW1iZXIpIDogdm9pZCB7XG4gICAgY29uc29sZS5hc3NlcnQoXG4gICAgICAgIG9sZFN0cmVhbXMubGVuZ3RoID09PSBuZXdTdHJlYW1zLmxlbmd0aCxcbiAgICAgICAgJ1N0cmVhbSBjb3VudCBtaXNzbWF0Y2ggYWZ0ZXIgbWFuaWZlc3QgdXBkYXRlIScpO1xuICAgIC8vIFRPRE9cbiAgICAvLyBJbXByb3ZlIHRoZSBzdHJlYW0gbWFwcGluZy4gRm9yIHNpbXBsaWNpdHkgc2FrZSB3ZSB3aWxsIGFzc3VtZSwgZm9yXG4gICAgLy8gbm93LCB0aGF0IHN0cmVhbXMgYXBwZWFycyBpbiBlYWNoIG1hbmlmZXN0IGluIHRoZSBzYW1lIG9yZGVyIGFuZFxuICAgIC8vIGluIHRoZSBzYW1lIGFtb3VudCBpLmUuIHdlIGFzc3VtZSBhbiAxOjEgbWFwcGluZyB3aXRoIHRoZSBuZXdcbiAgICAvLyBtYW5pZmVzdC5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9sZFN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5ld1NlZ21lbnRzID0gbmV3U3RyZWFtc1tpXS5zZWdtZW50SW5kZXguZ2V0U2VnbWVudHMoKTtcblxuICAgICAgb2xkU3RyZWFtc1tpXS5zZWdtZW50SW5kZXgubWVyZ2UobmV3U2VnbWVudHMpO1xuXG4gICAgICAvLyBBZGp1c3QgRFZSIHdpbmRvd1xuICAgICAgaWYgKGR2cldpbmRvd0xlbmd0aCkge1xuICAgICAgICBvbGRTdHJlYW1zW2ldLnNlZ21lbnRJbmRleC5hZGp1c3REdnJXaW5kb3coZHZyV2luZG93TGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IElNYW5pZmVzdCwgSU1hbmlmZXN0UGFyc2VyLCBJUHJlc2VudGF0aW9uLCBJUmVwcmVzZW50YXRpb24sIE1lZGlhVHlwZSwgU3RyZWFtVHlwZSB9IGZyb20gJy4vZGFzaC90eXBlcyc7XG5pbXBvcnQgeyBJTXNlQWRhcHRlciwgTXNlQWRhcHRlciB9IGZyb20gJy4vbXNlLWFkYXB0ZXInO1xuaW1wb3J0IHsgU3RyZWFtZXIgfSBmcm9tICcuL3N0cmVhbWVyJztcbmltcG9ydCB7IE1hbmlmZXN0UGFyc2VyIGFzIERhc2hQYXJzZXIgfSBmcm9tICcuL2Rhc2gvbWFuaWZlc3QtcGFyc2VyJztcblxuXG5pbnRlcmZhY2UgSVRyYWNrIHtcbiAgaWQ6IHN0cmluZztcbiAgb3JpZ2luYWxJZDogc3RyaW5nO1xuICB0eXBlOiBNZWRpYVR5cGU7XG4gIGticHM6IG51bWJlcjtcbiAgY29kZWNzOiBzdHJpbmc7XG4gIG1pbWVUeXBlOiBzdHJpbmc7XG59XG5pbnRlcmZhY2UgSVZpZGVvVHJhY2sgZXh0ZW5kcyBJVHJhY2sge1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgZnJhbWVSYXRlOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBJQXVkaW9UcmFjayBleHRlbmRzIElUcmFjayB7fVxuXG4vKipcbiAqIEEgbWluaW1hbCBNUEVHLURBU0ggcGxheWVyLlxuICovXG5leHBvcnQgY2xhc3MgUGxheWVyIHtcbiAgcHJpdmF0ZSB2aWRlb186IEhUTUxNZWRpYUVsZW1lbnQ7XG4gIHByaXZhdGUgbWFuaWZlc3RVcmxfOiBzdHJpbmcgPSAnJztcbiAgcHJpdmF0ZSBtYW5pZmVzdF86IElNYW5pZmVzdCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHBhcnNlcl86IElNYW5pZmVzdFBhcnNlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG1zZV86IElNc2VBZGFwdGVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc3RyZWFtZXJfOiBTdHJlYW1lciB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yICh2aWRlbzogSFRNTE1lZGlhRWxlbWVudCkge1xuICAgIHRoaXMudmlkZW9fID0gdmlkZW87XG4gIH1cblxuXG4gIC8qKlxuICAgKiBMb2FkcyBhbmQgcGxheSB0aGUgcHJvdmlkZWQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHN0cmVhbVVybCBUaGUgY29udGVudCBVUkwuXG4gICAqIEByZXR1cm4gUHJvbWlzZS5cbiAgICovXG4gIGFzeW5jIGxvYWQgKHN0cmVhbVVybDogc3RyaW5nKSA6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubWFuaWZlc3RVcmxfID0gc3RyZWFtVXJsO1xuICAgIHRoaXMucGFyc2VyXyA9IG5ldyBEYXNoUGFyc2VyKCk7XG4gICAgdGhpcy5tc2VfID0gbmV3IE1zZUFkYXB0ZXIodGhpcy52aWRlb18pO1xuICAgIHRoaXMuc3RyZWFtZXJfID0gbmV3IFN0cmVhbWVyKHRoaXMubXNlXywgdGhpcy5nZXRQcmVzZW50YXRpb25JbXBsXygpKTtcblxuICAgIHRoaXMubWFuaWZlc3RfID0gYXdhaXQgdGhpcy5wYXJzZXJfLnN0YXJ0KHRoaXMubWFuaWZlc3RVcmxfKTtcblxuICAgIGNvbnN0IGluaXRTdHJlYW1zOiBNYXA8TWVkaWFUeXBlLCBJUmVwcmVzZW50YXRpb24+ID0gbmV3IE1hcCgpO1xuXG4gICAgaW5pdFN0cmVhbXMuc2V0KFxuICAgICAgICBNZWRpYVR5cGUuVklERU8sIHRoaXMucGlja0hpZ2hlc3RLYnBzXyh0aGlzLm1hbmlmZXN0Xy52aWRlbykpO1xuICAgIGluaXRTdHJlYW1zLnNldChcbiAgICAgICAgTWVkaWFUeXBlLkFVRElPLCB0aGlzLnBpY2tIaWdoZXN0S2Jwc18odGhpcy5tYW5pZmVzdF8uYXVkaW8pKTtcblxuICAgIGF3YWl0IHRoaXMuc3RyZWFtZXJfLnNldHVwKGluaXRTdHJlYW1zKTtcbiAgICBjb25zdCBzdHJlYW1pbmdTdGFydGVkID0gYXdhaXQgdGhpcy5zdHJlYW1lcl8uc3RhcnQoKTtcbiAgICBpZiAoc3RyZWFtaW5nU3RhcnRlZCkge1xuICAgICAgdGhpcy52aWRlb18ucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3Qgc3RhcnQgc3RyZWFtaW5nIScpO1xuICAgICAgdGhyb3cgRXJyb3IoJ1N0cmVhbWluZyBTdGFydCBmYWlsZWQnKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgcGxheWVyLlxuICAgKi9cbiAgYXN5bmMgc3RvcCAoKSA6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLnBhcnNlcl8pIHtcbiAgICAgIHRoaXMucGFyc2VyXy5zdG9wKCk7XG4gICAgICB0aGlzLnBhcnNlcl8gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cmVhbWVyXykge1xuICAgICAgdGhpcy5zdHJlYW1lcl8uc3RvcCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1zZV8pIHtcbiAgICAgIHRoaXMubXNlXyA9IG51bGw7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogR2V0IGFsbCB2aWRlbyB0cmFja3MuXG4gICAqIEByZXR1cm5zIEFsbCBhdmFpbGFibGUgdmlkZW8gdHJhY2tzXG4gICAqL1xuICBnZXRBbGxWaWRlbyAoKSA6IElWaWRlb1RyYWNrW10ge1xuICAgIGlmICh0aGlzLm1hbmlmZXN0XyAmJiB0aGlzLm1hbmlmZXN0Xy52aWRlby5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYW5pZmVzdF8udmlkZW8ubWFwKHZpZGVvID0+IHRoaXMuZ2V0UHVibGljVmlkZW9fKHZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCBhbGwgYXVkaW8gdHJhY2tzLlxuICAgKiBAcmV0dXJucyBBbGwgYXZhaWxhYmxlIGF1ZGlvIHRyYWNrcy5cbiAgICovXG4gIGdldEFsbEF1ZGlvICgpIDogSUF1ZGlvVHJhY2tbXSB7XG4gICAgaWYgKHRoaXMubWFuaWZlc3RfICYmIHRoaXMubWFuaWZlc3RfLmF1ZGlvLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLm1hbmlmZXN0Xy5hdWRpby5tYXAoYXVkaW8gPT4gdGhpcy5nZXRQdWJsaWNBdWRpb18oYXVkaW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYWN0aXZlIChjdXJyZW50bHkgYnVmZmVyaW5nKSB2aWRlbyBzdHJlYW0uXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50bHkgYWN0aXZlIHZpZGVvIHN0cmVhbSBvciBudWxsLlxuICAgKi9cbiAgZ2V0QWN0aXZlVmlkZW8gKCkgOiBJVmlkZW9UcmFjayB8IG51bGwge1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuc3RyZWFtZXJfPy5nZXRBY3RpdmVTdHJlYW0oTWVkaWFUeXBlLlZJREVPKSB8fCBudWxsO1xuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFB1YmxpY1ZpZGVvXyhhY3RpdmUpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0IHRoZSBhY3RpdmUgKGN1cnJlbnRseSBidWZmZXJpbmcpIGF1ZGlvIHN0cmVhbS5cbiAgICogQHJldHVybnMgVGhlIGN1cnJlbnRseSBhY3RpdmUgYXVkaW8gc3RyZWFtIG9yIG51bGwuXG4gICAqL1xuICBnZXRBY3RpdmVBdWRpbyAoKSA6IElBdWRpb1RyYWNrIHwgbnVsbCB7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5zdHJlYW1lcl8/LmdldEFjdGl2ZVN0cmVhbShNZWRpYVR5cGUuQVVESU8pIHx8IG51bGw7XG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UHVibGljQXVkaW9fKGFjdGl2ZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaXNMaXZlICgpIDogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMubWFuaWZlc3RfICYmIHRoaXMubWFuaWZlc3RfLnR5cGUgPT09IFN0cmVhbVR5cGUuTElWRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIEFuIGltcGxlbWVudGF0aW9uIG9mIElQcmVzZW50YXRpb24uXG4gICAqL1xuICBwcml2YXRlIGdldFByZXNlbnRhdGlvbkltcGxfICgpIDogSVByZXNlbnRhdGlvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTGl2ZTogKCkgPT4gdGhpcy5pc0xpdmUoKSxcbiAgICAgIGdldFN0YXJ0VGltZTogKCkgPT4gKHRoaXMubWFuaWZlc3RfICYmIHRoaXMubWFuaWZlc3RfLnN0YXJ0VGltZSkgfHwgMCxcbiAgICAgIGdldE1heFNlZ21lbnREdXJhdGlvbjogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5tYW5pZmVzdF8pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYW5pZmVzdF8ubWF4U2VnbWVudER1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIGdldERlbGF5OiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm1hbmlmZXN0Xykge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hbmlmZXN0Xy5kZWxheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBnZXRQb3NpdGlvbjogKCkgPT4gdGhpcy52aWRlb18uY3VycmVudFRpbWUgfHwgMCwgLy8gVE9ETzogTWluZCByZWFkeSBzdGF0ZVxuICAgICAgZ2V0RHVyYXRpb246ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMubWFuaWZlc3RfKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFuaWZlc3RfLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuXG4gIHByaXZhdGUgcGlja0hpZ2hlc3RLYnBzXyAoc3RyZWFtczogSVJlcHJlc2VudGF0aW9uW10pIDogSVJlcHJlc2VudGF0aW9uIHtcbiAgICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UoKHMxLCBzMikgPT4gKHMxLmticHMgPiBzMi5rYnBzKSA/IHMxIDogczIpO1xuICB9XG5cblxuICBwcml2YXRlIGdldFB1YmxpY1ZpZGVvXyAodmlkZW86IElSZXByZXNlbnRhdGlvbikgOiBJVmlkZW9UcmFjayB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB2aWRlby5pZCxcbiAgICAgIG9yaWdpbmFsSWQ6IHZpZGVvLm9yaWdpbmFsSWQsXG4gICAgICB0eXBlOiB2aWRlby50eXBlLFxuICAgICAga2JwczogdmlkZW8ua2JwcyxcbiAgICAgIGNvZGVjczogdmlkZW8uY29kZWNzLFxuICAgICAgbWltZVR5cGU6IHZpZGVvLm1pbWVUeXBlLFxuICAgICAgd2lkdGg6IHZpZGVvLndpZHRoIGFzIG51bWJlcixcbiAgICAgIGhlaWdodDogdmlkZW8uaGVpZ2h0IGFzIG51bWJlcixcbiAgICAgIGZyYW1lUmF0ZTogdmlkZW8uZnJhbWVSYXRlIGFzIG51bWJlclxuICAgIH07XG4gIH1cblxuXG4gIHByaXZhdGUgZ2V0UHVibGljQXVkaW9fIChhdWRpbzogSVJlcHJlc2VudGF0aW9uKSA6IElBdWRpb1RyYWNrIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGF1ZGlvLmlkLFxuICAgICAgb3JpZ2luYWxJZDogYXVkaW8ub3JpZ2luYWxJZCxcbiAgICAgIHR5cGU6IGF1ZGlvLnR5cGUsXG4gICAgICBrYnBzOiBhdWRpby5rYnBzLFxuICAgICAgY29kZWNzOiBhdWRpby5jb2RlY3MsXG4gICAgICBtaW1lVHlwZTogYXVkaW8ubWltZVR5cGVcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBQbGF5ZXIgfSBmcm9tICcuL3BsYXllcic7XG5cbmNvbnN0IGxpYiA9IHtcbiAgUGxheWVyXG59O1xuXG5leHBvcnQgZGVmYXVsdCBsaWI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///743\n")}},__webpack_require__={d:(Q,U)=>{for(var F in U)__webpack_require__.o(U,F)&&!__webpack_require__.o(Q,F)&&Object.defineProperty(Q,F,{enumerable:!0,get:U[F]})},o:(Q,U)=>Object.prototype.hasOwnProperty.call(Q,U)},__webpack_exports__={};return __webpack_modules__[743](0,__webpack_exports__,__webpack_require__),__webpack_exports__=__webpack_exports__.default,__webpack_exports__})()));